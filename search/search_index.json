{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SQLDelight generates typesafe kotlin APIs from your SQL statements. It verifies your schema, statements, and migrations at compile-time and provides IDE features like autocomplete and refactoring which make writing and maintaining SQL simple. SQLDelight understands your existing SQL schema. CREATE TABLE hockey_player ( id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT , name TEXT NOT NULL , number INTEGER NOT NULL ); It generates typesafe code for any labeled SQL statements. SQLDelight supports a variety of dialects and platforms: SQLite Android Native (iOS, macOS, or Windows) JVM Javascript (Work In Progress) Multiplatform MySQL (JVM) PostgreSQL (JVM) (Experimental) HSQL/H2 (JVM) (Experimental)","title":"Overview"},{"location":"code_of_conduct/","text":"Open Source Code of Conduct At Square, we are committed to contributing to the open source community and simplifying the process of releasing and managing open source software. We\u2019ve seen incredible support and enthusiasm from thousands of people who have already contributed to our projects\u200a\u2014\u200aand we want to ensure our community continues to be truly open for everyone. This code of conduct outlines our expectations for participants, as well as steps to reporting unacceptable behavior. We are committed to providing a welcoming and inspiring community for all and expect our code of conduct to be honored. Square\u2019s open source community strives to: Be open : We invite anyone to participate in any aspect of our projects. Our community is open, and any responsibility can be carried by a contributor who demonstrates the required capacity and competence. Be considerate : People use our work, and we depend on the work of others. Consider users and colleagues before taking action. For example, changes to code, infrastructure, policy, and documentation may negatively impact others. Be respectful : We expect people to work together to resolve conflict, assume good intentions, and act with empathy. Do not turn disagreements into personal attacks. Be collaborative : Collaboration reduces redundancy and improves the quality of our work. We strive for transparency within our open source community, and we work closely with upstream developers and others in the free software community to coordinate our efforts. Be pragmatic : Questions are encouraged and should be asked early in the process to avoid problems later. Be thoughtful and considerate when seeking out the appropriate forum for your questions. Those who are asked should be responsive and helpful. Step down considerately : Members of every project come and go. When somebody leaves or disengages from the project, they should make it known and take the proper steps to ensure that others can pick up where they left off. This code is not exhaustive or complete. It serves to distill our common understanding of a collaborative, shared environment, and goals. We expect it to be followed in spirit as much as in the letter. Diversity Statement We encourage everyone to participate and are committed to building a community for all. Although we may not be able to satisfy everyone, we all agree that everyone is equal. Whenever a participant has made a mistake, we expect them to take responsibility for it. If someone has been harmed or offended, it is our responsibility to listen carefully and respectfully, and do our best to right the wrong. Although this list cannot be exhaustive, we explicitly honor diversity in age, culture, ethnicity, gender identity or expression, language, national origin, political beliefs, profession, race, religion, sexual orientation, socioeconomic status, and technical ability. We will not tolerate discrimination based on any of the protected characteristics above, including participants with disabilities. Reporting Issues If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . For more details, please see our Reporting Guidelines below. Thanks Some of the ideas and wording for the statements and guidelines above were based on work by the Twitter , Ubuntu , GDC , and Django communities. We are thankful for their work. Reporting Guide If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . All reports will be handled with discretion. In your report please include: Your contact information. Names (real, nicknames, or pseudonyms) of any individuals involved. If there are additional witnesses, please include them as well. Your account of what occurred, and if you believe the incident is ongoing. If there is a publicly available record (e.g. a mailing list archive or a public IRC logger), please include a link. Any additional information that may be helpful. After filing a report, a representative from the Square Code of Conduct committee will contact you personally. The committee will then review the incident, follow up with any additional questions, and make a decision as to how to respond. Anyone asked to stop unacceptable behavior is expected to comply immediately. If an individual engages in unacceptable behavior, the Square Code of Conduct committee may take any action they deem appropriate, up to and including a permanent ban from all of Square spaces without warning.","title":"Code of Conduct"},{"location":"code_of_conduct/#open-source-code-of-conduct","text":"At Square, we are committed to contributing to the open source community and simplifying the process of releasing and managing open source software. We\u2019ve seen incredible support and enthusiasm from thousands of people who have already contributed to our projects\u200a\u2014\u200aand we want to ensure our community continues to be truly open for everyone. This code of conduct outlines our expectations for participants, as well as steps to reporting unacceptable behavior. We are committed to providing a welcoming and inspiring community for all and expect our code of conduct to be honored. Square\u2019s open source community strives to: Be open : We invite anyone to participate in any aspect of our projects. Our community is open, and any responsibility can be carried by a contributor who demonstrates the required capacity and competence. Be considerate : People use our work, and we depend on the work of others. Consider users and colleagues before taking action. For example, changes to code, infrastructure, policy, and documentation may negatively impact others. Be respectful : We expect people to work together to resolve conflict, assume good intentions, and act with empathy. Do not turn disagreements into personal attacks. Be collaborative : Collaboration reduces redundancy and improves the quality of our work. We strive for transparency within our open source community, and we work closely with upstream developers and others in the free software community to coordinate our efforts. Be pragmatic : Questions are encouraged and should be asked early in the process to avoid problems later. Be thoughtful and considerate when seeking out the appropriate forum for your questions. Those who are asked should be responsive and helpful. Step down considerately : Members of every project come and go. When somebody leaves or disengages from the project, they should make it known and take the proper steps to ensure that others can pick up where they left off. This code is not exhaustive or complete. It serves to distill our common understanding of a collaborative, shared environment, and goals. We expect it to be followed in spirit as much as in the letter.","title":"Open Source Code of Conduct"},{"location":"code_of_conduct/#diversity-statement","text":"We encourage everyone to participate and are committed to building a community for all. Although we may not be able to satisfy everyone, we all agree that everyone is equal. Whenever a participant has made a mistake, we expect them to take responsibility for it. If someone has been harmed or offended, it is our responsibility to listen carefully and respectfully, and do our best to right the wrong. Although this list cannot be exhaustive, we explicitly honor diversity in age, culture, ethnicity, gender identity or expression, language, national origin, political beliefs, profession, race, religion, sexual orientation, socioeconomic status, and technical ability. We will not tolerate discrimination based on any of the protected characteristics above, including participants with disabilities.","title":"Diversity Statement"},{"location":"code_of_conduct/#reporting-issues","text":"If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . For more details, please see our Reporting Guidelines below.","title":"Reporting Issues"},{"location":"code_of_conduct/#thanks","text":"Some of the ideas and wording for the statements and guidelines above were based on work by the Twitter , Ubuntu , GDC , and Django communities. We are thankful for their work.","title":"Thanks"},{"location":"code_of_conduct/#reporting-guide","text":"If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . All reports will be handled with discretion. In your report please include: Your contact information. Names (real, nicknames, or pseudonyms) of any individuals involved. If there are additional witnesses, please include them as well. Your account of what occurred, and if you believe the incident is ongoing. If there is a publicly available record (e.g. a mailing list archive or a public IRC logger), please include a link. Any additional information that may be helpful. After filing a report, a representative from the Square Code of Conduct committee will contact you personally. The committee will then review the incident, follow up with any additional questions, and make a decision as to how to respond. Anyone asked to stop unacceptable behavior is expected to comply immediately. If an individual engages in unacceptable behavior, the Square Code of Conduct committee may take any action they deem appropriate, up to and including a permanent ban from all of Square spaces without warning.","title":"Reporting Guide"},{"location":"android_sqlite/","text":"Getting Started on Android First apply the gradle plugin in your project. buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.4.1' } } apply plugin: 'com.squareup.sqldelight' Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: dependencies { implementation \"com.squareup.sqldelight:android-driver:1.4.1\" } val driver : SqlDriver = AndroidSqliteDriver ( Database . Schema , context , \"test.db\" ) It's recommended to switch Android Studio to use the \"Project\" view instead of the \"Android\" view of your files, in order to find and edit SQLDelight files. SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Getting Started"},{"location":"android_sqlite/#getting-started-on-android","text":"First apply the gradle plugin in your project. buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.4.1' } } apply plugin: 'com.squareup.sqldelight' Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: dependencies { implementation \"com.squareup.sqldelight:android-driver:1.4.1\" } val driver : SqlDriver = AndroidSqliteDriver ( Database . Schema , context , \"test.db\" ) It's recommended to switch Android Studio to use the \"Project\" view instead of the \"Android\" view of your files, in order to find and edit SQLDelight files. SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Getting Started on Android"},{"location":"android_sqlite/android_paging/","text":"Android Paging To use SQLDelight with Android's Paging Library add a dependency on the paging extension artifact. dependencies { implementation \"com.squareup.sqldelight:android-paging-extensions:1.2.1\" } To create a DataSource write a query to get the number of rows and a query that takes an offset and a limit. countPlayers : SELECT count ( * ) FROM hockeyPlayer ; players : SELECT * FROM hockeyPlayer LIMIT : limit OFFSET : offset ; val dataSource = QueryDataSourceFactory ( queryProvider = playerQueries :: players , countQuery = playerQueries . countPlayers (), transacter = playerQueries ). create ()","title":"Android Paging"},{"location":"android_sqlite/android_paging/#android-paging","text":"To use SQLDelight with Android's Paging Library add a dependency on the paging extension artifact. dependencies { implementation \"com.squareup.sqldelight:android-paging-extensions:1.2.1\" } To create a DataSource write a query to get the number of rows and a query that takes an offset and a limit. countPlayers : SELECT count ( * ) FROM hockeyPlayer ; players : SELECT * FROM hockeyPlayer LIMIT : limit OFFSET : offset ; val dataSource = QueryDataSourceFactory ( queryProvider = playerQueries :: players , countQuery = playerQueries . countPlayers (), transacter = playerQueries ). create ()","title":"Android Paging"},{"location":"android_sqlite/coroutines/","text":"Flow To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides: dependencies { implementation \"com.squareup.sqldelight:coroutines-extensions-jvm:1.4.1\" } val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Coroutines"},{"location":"android_sqlite/coroutines/#flow","text":"To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides: dependencies { implementation \"com.squareup.sqldelight:coroutines-extensions-jvm:1.4.1\" } val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Flow"},{"location":"android_sqlite/custom_projections/","text":"Projections By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"android_sqlite/custom_projections/#projections","text":"By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"android_sqlite/gradle/","text":"Gradle For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // The dialect version you would like to target // Defaults to \"sqlite:3.18\" dialect = \"sqlite:3.24\" } } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) dialect = \"sqlite:3.24\" } } Dependencies You can specify schema dependencies on another module: sqldelight { MyDatabase { package = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: sqldelight { MyDatabase { package = \"com.example.projectb\" } }","title":"Gradle"},{"location":"android_sqlite/gradle/#gradle","text":"For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // The dialect version you would like to target // Defaults to \"sqlite:3.18\" dialect = \"sqlite:3.24\" } } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) dialect = \"sqlite:3.24\" } }","title":"Gradle"},{"location":"android_sqlite/gradle/#dependencies","text":"You can specify schema dependencies on another module: sqldelight { MyDatabase { package = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: sqldelight { MyDatabase { package = \"com.example.projectb\" } }","title":"Dependencies"},{"location":"android_sqlite/grouping_statements/","text":"You can group multiple SQL statements together to be executed at once: upsert { UPDATE myTable SET column1 = : column1 , column2 = : column2 WHERE id = : id ; INSERT OR IGNORE INTO myTable ( id , column1 , column2 ) VALUES (: id , : column1 , : column2 ); }","title":"Grouping Statements"},{"location":"android_sqlite/intellij_plugin/","text":"IntelliJ Plugin The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight MarketplaceWidget.setupMarketplaceWidget('install', 8191, \"#intellij-plugin-button\");","title":"IntelliJ Plugin"},{"location":"android_sqlite/intellij_plugin/#intellij-plugin","text":"The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight MarketplaceWidget.setupMarketplaceWidget('install', 8191, \"#intellij-plugin-button\");","title":"IntelliJ Plugin"},{"location":"android_sqlite/migrations/","text":"Migrations The .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. Versioning The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; These SQL statements are run by Database.Schema.migrate() . Migration files go in the same source set as your .sq files. Verifying Migrations You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task, which is available once you specify a schemaOutputDirectory , as described in the gradle.md . You should probably do this before you create your first migration.","title":"Migrations"},{"location":"android_sqlite/migrations/#migrations","text":"The .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date.","title":"Migrations"},{"location":"android_sqlite/migrations/#versioning","text":"The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; These SQL statements are run by Database.Schema.migrate() . Migration files go in the same source set as your .sq files.","title":"Versioning"},{"location":"android_sqlite/migrations/#verifying-migrations","text":"You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task, which is available once you specify a schemaOutputDirectory , as described in the gradle.md . You should probably do this before you create your first migration.","title":"Verifying Migrations"},{"location":"android_sqlite/query_arguments/","text":"Bind Args .sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments. Type Inference SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Named Arguments Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" ) Variable Arguments Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" )) Inserts INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Arguments"},{"location":"android_sqlite/query_arguments/#bind-args","text":".sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments.","title":"Bind Args"},{"location":"android_sqlite/query_arguments/#type-inference","text":"SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\"","title":"Type Inference"},{"location":"android_sqlite/query_arguments/#named-arguments","text":"Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Named Arguments"},{"location":"android_sqlite/query_arguments/#variable-arguments","text":"Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" ))","title":"Variable Arguments"},{"location":"android_sqlite/query_arguments/#inserts","text":"INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Inserts"},{"location":"android_sqlite/resources/","text":"Other Resources Guides SQLDelight 1.x Quickstart Guide for Android","title":"Resources"},{"location":"android_sqlite/resources/#other-resources","text":"","title":"Other Resources"},{"location":"android_sqlite/resources/#guides","text":"SQLDelight 1.x Quickstart Guide for Android","title":"Guides"},{"location":"android_sqlite/rxjava/","text":"RxJava To observe a query, depend on the RxJava extensions artifact and use the extension method it provides: dependencies { implementation \"com.squareup.sqldelight:rxjava3-extensions:1.4.1\" } val players : Observable < List < HockeyPlayer >> = playerQueries . selectAll () . asObservable () . mapToList () Note: For RxJava 2, use rxjava2-extensions as the artifact name.","title":"RxJava"},{"location":"android_sqlite/rxjava/#rxjava","text":"To observe a query, depend on the RxJava extensions artifact and use the extension method it provides: dependencies { implementation \"com.squareup.sqldelight:rxjava3-extensions:1.4.1\" } val players : Observable < List < HockeyPlayer >> = playerQueries . selectAll () . asObservable () . mapToList () Note: For RxJava 2, use rxjava2-extensions as the artifact name.","title":"RxJava"},{"location":"android_sqlite/testing/","text":"In some tests (like verification of migrations) you might wish to swap out the Android driver with the JVM driver , enabling you to test code involving the database without needing an Android emulator or physical device. To do that use the jvm SQLite driver: dependencies { testImplementation 'com.squareup.sqldelight:sqlite-driver:1.4.1' } // When your test needs a driver @Before fun before () { driver = JdbcSqliteDriver ( JdbcSqliteDriver . IN_MEMORY ) Database . Schema . create ( driver ) } If you are using the SQLite that comes bundled with Android (rather than shipping your own ), you can override the version of sqlite-jdbc to one that matches your Android minSdkVersion , for example for API 23 use SQLite 3.8.10.2: dependencies { testImplementation ( 'org.xerial:sqlite-jdbc:3.8.10.2' ) { // Override the version of sqlite used by sqlite-driver to match Android API 23 force = true } }","title":"Testing"},{"location":"android_sqlite/transactions/","text":"API If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithReturn function. val players = database . playerQueries . transactionWithReturn { database . playerQueries . selectAll (). executeAsList () } Rollback Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted = database . playerQueries . transactionWithReturn { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size } Callbacks You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \"${players.size} players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"android_sqlite/transactions/#api","text":"If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithReturn function. val players = database . playerQueries . transactionWithReturn { database . playerQueries . selectAll (). executeAsList () }","title":"API"},{"location":"android_sqlite/transactions/#rollback","text":"Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted = database . playerQueries . transactionWithReturn { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size }","title":"Rollback"},{"location":"android_sqlite/transactions/#callbacks","text":"You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \"${players.size} players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Callbacks"},{"location":"android_sqlite/types/","text":"SQLite Types SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. SQLDelight natively supports Long, Double, String, ByteArray, Int, Short, Float, and Booleans. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray some_int INTEGER AS Int , -- Stored as INTEGER in db, retrieved as Int some_short INTEGER AS Short , -- Stored as INTEGER in db, retrieved as Short some_float REAL AS Float -- Stored as REAL in db, retrieved as Float ); Boolean columns are stored in the db as INTEGER , and so they can be given INTEGER column constraints. Use DEFAULT 0 to default to false, for example. CREATE TABLE hockey_player ( injured INTEGER AS Boolean DEFAULT 0 ) Custom Column Types If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) ) Enums As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Types"},{"location":"android_sqlite/types/#sqlite-types","text":"SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. SQLDelight natively supports Long, Double, String, ByteArray, Int, Short, Float, and Booleans. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray some_int INTEGER AS Int , -- Stored as INTEGER in db, retrieved as Int some_short INTEGER AS Short , -- Stored as INTEGER in db, retrieved as Short some_float REAL AS Float -- Stored as REAL in db, retrieved as Float ); Boolean columns are stored in the db as INTEGER , and so they can be given INTEGER column constraints. Use DEFAULT 0 to default to false, for example. CREATE TABLE hockey_player ( injured INTEGER AS Boolean DEFAULT 0 )","title":"SQLite Types"},{"location":"android_sqlite/types/#custom-column-types","text":"If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) )","title":"Custom Column Types"},{"location":"android_sqlite/types/#enums","text":"As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Enums"},{"location":"android_sqlite/upgrading/","text":"Upgrading from Versions before 1.0 If you're still on SQLDelight 0.6 doing the upgrade to 0.7 first so you stay on the SupportSQLite artifact will likely be easiest Upgrade the gradle plugin from 0.7 to 0.7.1. This will upgrade the arch.persistence.db dependency to 1.1.1, but should have no effect on your usage of sqldelight. Upgrade the gradle plugin from 0.7.1 to 0.7.2. This changes the runtime package from com.squareup.sqldelight to com.squareup.sqldelight.prerelease , so you will need to change references in your own code. Upgrade the gradle plugin from 0.7.2 to 0.9.0. This upgrades the transitive dependencies and generated code to instead use AndroidX, which is a requirement of SQLDelight. This should be done at the same time as you upgrading your own project to AndroidX, and cannot be done separately since SQLDelight generates code which references android support/AndroidX. ALTERNATIVELY Upgrade the gradle plugin from 0.7 to 0.8.0 before then upgrading to 0.9.0. This upgrades to AndroidX without changing the sqldelight package name to com.squareup.sqldelight.prerelease Suppose on SQLDelight 0.9 you have this User.sq file: CREATE TABLE user ( id INTEGER NOT NULL PRIMARY KEY , name TEXT NOT NULL ); insertDefaultData : INSERT INTO user VALUES ( 1 , 'Alec' ); users : SELECT * FROM user ; names : SELECT name FROM user ; insertUser : INSERT INTO user VALUES ( ? , ? ); This will generate the UserModel class with methods for your queries. Copy and paste all *Model.java files out of the build directory and into your src/main/java folder. Upgrade the gradle plugin from 0.9 to 1.0.0-rc4. Note your build will fail at this point because of the model code having undefined references to the old SQL Delight runtime (like SqlDelightStatement ). To add these back in add an implementation dependency on com.squareup.sqldelight:runtime:0.9.0 . At this point your build should still be working, but changes to .sq files will not be reflected in your *Model.java files. If things aren't working at this point, please file an issue! Begin by modifying your SupportSQLiteOpenHelper.Callback to call into the now generated Database which holds generated code for SQL Delight 1.0: //Before @Override void onCreate ( SupportSQLiteDatabase db ) { db . execSql ( UserModel . CREATE_TABLE ); db . execSql ( UserModel . INSERTDEFAULTDATA ); // Other create table/initialization } In SQL Delight 1.0 all unlabeled statements in .sq files (including CREATE statements) will be run during onCreate , so we can remove the insertDefaultData identifier from above: User.sq ... --insertDefaultData: INSERT INTO user VALUES ( 1 , 'Alec' ); ... and now your SupportSQLiteOpenHelper.Callback should call into the Database for create @Override void onCreate ( SupportSQLiteDatabase db ) { SqlDriver driver = AndroidSqliteDriver ( db ) Database . Schema . create ( driver ) } You can do the same for your migrations if you place them in .sqm files, but thats not necessary part of the upgrade. At this point things should still work normally. Next add in the code to create your Database as part of an object graph/singleton pattern/whevs: @Provides @Singleton static SupportSQLiteOpenHelper provideDatabaseHelper ( @App Context context ) { SupportSQLiteOpenHelper . Configuration config = SupportSQLiteOpenHelper . Configuration . builder ( context ) . name ( DATABASE_NAME ) . callback ( new MyDatabaseCallback ()) . build (); return new FrameworkSQLiteOpenHelperFactory (). create ( config ); } @Provides @Singleton static Database provideDatabase ( SupportSQLiteOpenHelper helper ) { return new Database ( new AndroidSqliteDriver ( helper )); } If you're also using SQL Brite make sure you create a BriteDatabase with the same SupportSQLiteOpenHelper that's being used to create the Database . Things should still be working. The following assume you're using SQL Brite to get reactive callbacks from the database, but upgrades using only SQL Delight will be similar. Mutating queries can be converted individually by using the Database : before: private val insertUser : UserModel . InsertUser by lazy { UserModel . InsertUser ( datbaseOpenHelper . writableDatabase ) } insertUser . bind ( 2 , \"Jake\" ) insertUser . executeInsert () after: database . userQueries . insertUser ( 2 , \"Jake\" ) You no longer need a \"Factory\" type to perform queries, the query wrapper is all that is needed. before: val query = User . FACTORY . users () val usersObservable = briteDatabase . createQuery ( query . tables , query . statement , query . args ) . mapToList ( User . FACTORY . usersMapper () :: map ) after: val usersObservable = database . userQueries . users () . asObservable ( Schedulers . io ()) // The scheduler to run the query on. . mapToList () If you still want to use a custom type, pass it as a parameter to the query. val myUsersObservable = database . userQueries . users ( :: MyUser ) . asObservable ( Schedulers . io ()) . mapToList () Once you no longer have references to UserModel.java , delete the whole class. Repeat for each of your *Model.java files until upgrading is complete!","title":"Upgrading Pre-1.0"},{"location":"android_sqlite/upgrading/#upgrading-from-versions-before-10","text":"If you're still on SQLDelight 0.6 doing the upgrade to 0.7 first so you stay on the SupportSQLite artifact will likely be easiest Upgrade the gradle plugin from 0.7 to 0.7.1. This will upgrade the arch.persistence.db dependency to 1.1.1, but should have no effect on your usage of sqldelight. Upgrade the gradle plugin from 0.7.1 to 0.7.2. This changes the runtime package from com.squareup.sqldelight to com.squareup.sqldelight.prerelease , so you will need to change references in your own code. Upgrade the gradle plugin from 0.7.2 to 0.9.0. This upgrades the transitive dependencies and generated code to instead use AndroidX, which is a requirement of SQLDelight. This should be done at the same time as you upgrading your own project to AndroidX, and cannot be done separately since SQLDelight generates code which references android support/AndroidX. ALTERNATIVELY Upgrade the gradle plugin from 0.7 to 0.8.0 before then upgrading to 0.9.0. This upgrades to AndroidX without changing the sqldelight package name to com.squareup.sqldelight.prerelease Suppose on SQLDelight 0.9 you have this User.sq file: CREATE TABLE user ( id INTEGER NOT NULL PRIMARY KEY , name TEXT NOT NULL ); insertDefaultData : INSERT INTO user VALUES ( 1 , 'Alec' ); users : SELECT * FROM user ; names : SELECT name FROM user ; insertUser : INSERT INTO user VALUES ( ? , ? ); This will generate the UserModel class with methods for your queries. Copy and paste all *Model.java files out of the build directory and into your src/main/java folder. Upgrade the gradle plugin from 0.9 to 1.0.0-rc4. Note your build will fail at this point because of the model code having undefined references to the old SQL Delight runtime (like SqlDelightStatement ). To add these back in add an implementation dependency on com.squareup.sqldelight:runtime:0.9.0 . At this point your build should still be working, but changes to .sq files will not be reflected in your *Model.java files. If things aren't working at this point, please file an issue! Begin by modifying your SupportSQLiteOpenHelper.Callback to call into the now generated Database which holds generated code for SQL Delight 1.0: //Before @Override void onCreate ( SupportSQLiteDatabase db ) { db . execSql ( UserModel . CREATE_TABLE ); db . execSql ( UserModel . INSERTDEFAULTDATA ); // Other create table/initialization } In SQL Delight 1.0 all unlabeled statements in .sq files (including CREATE statements) will be run during onCreate , so we can remove the insertDefaultData identifier from above: User.sq ... --insertDefaultData: INSERT INTO user VALUES ( 1 , 'Alec' ); ... and now your SupportSQLiteOpenHelper.Callback should call into the Database for create @Override void onCreate ( SupportSQLiteDatabase db ) { SqlDriver driver = AndroidSqliteDriver ( db ) Database . Schema . create ( driver ) } You can do the same for your migrations if you place them in .sqm files, but thats not necessary part of the upgrade. At this point things should still work normally. Next add in the code to create your Database as part of an object graph/singleton pattern/whevs: @Provides @Singleton static SupportSQLiteOpenHelper provideDatabaseHelper ( @App Context context ) { SupportSQLiteOpenHelper . Configuration config = SupportSQLiteOpenHelper . Configuration . builder ( context ) . name ( DATABASE_NAME ) . callback ( new MyDatabaseCallback ()) . build (); return new FrameworkSQLiteOpenHelperFactory (). create ( config ); } @Provides @Singleton static Database provideDatabase ( SupportSQLiteOpenHelper helper ) { return new Database ( new AndroidSqliteDriver ( helper )); } If you're also using SQL Brite make sure you create a BriteDatabase with the same SupportSQLiteOpenHelper that's being used to create the Database . Things should still be working. The following assume you're using SQL Brite to get reactive callbacks from the database, but upgrades using only SQL Delight will be similar. Mutating queries can be converted individually by using the Database : before: private val insertUser : UserModel . InsertUser by lazy { UserModel . InsertUser ( datbaseOpenHelper . writableDatabase ) } insertUser . bind ( 2 , \"Jake\" ) insertUser . executeInsert () after: database . userQueries . insertUser ( 2 , \"Jake\" ) You no longer need a \"Factory\" type to perform queries, the query wrapper is all that is needed. before: val query = User . FACTORY . users () val usersObservable = briteDatabase . createQuery ( query . tables , query . statement , query . args ) . mapToList ( User . FACTORY . usersMapper () :: map ) after: val usersObservable = database . userQueries . users () . asObservable ( Schedulers . io ()) // The scheduler to run the query on. . mapToList () If you still want to use a custom type, pass it as a parameter to the query. val myUsersObservable = database . userQueries . users ( :: MyUser ) . asObservable ( Schedulers . io ()) . mapToList () Once you no longer have references to UserModel.java , delete the whole class. Repeat for each of your *Model.java files until upgrading is complete!","title":"Upgrading from Versions before 1.0"},{"location":"common/coroutines-multiplatform/","text":"Flow To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides: kotlin { sourceSets . commonMain . dependencies { implementation \"com.squareup.sqldelight:coroutines-extensions:1.4.1\" } } val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Coroutines multiplatform"},{"location":"common/coroutines-multiplatform/#flow","text":"To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides: kotlin { sourceSets . commonMain . dependencies { implementation \"com.squareup.sqldelight:coroutines-extensions:1.4.1\" } } val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Flow"},{"location":"common/coroutines-usage/","text":"val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Coroutines usage"},{"location":"common/coroutines/","text":"Flow To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides: dependencies { implementation \"com.squareup.sqldelight:coroutines-extensions-jvm:1.4.1\" } val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Coroutines"},{"location":"common/coroutines/#flow","text":"To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides: dependencies { implementation \"com.squareup.sqldelight:coroutines-extensions-jvm:1.4.1\" } val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Flow"},{"location":"common/custom_column_types/","text":"Custom Column Types If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) ) Enums As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Custom column types"},{"location":"common/custom_column_types/#custom-column-types","text":"If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) )","title":"Custom Column Types"},{"location":"common/custom_column_types/#enums","text":"As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Enums"},{"location":"common/custom_projections/","text":"Projections By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"common/custom_projections/#projections","text":"By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"common/gradle-common-groovy-properties/","text":"// Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [\"db\"] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file(\"src/main/sqldelight/databases\") // Optionally specify schema dependencies on other gradle projects dependency project(':OtherProject') // The dialect version you would like to target // Defaults to \"sqlite:3.18\" dialect = \"sqlite:3.24\"","title":"Gradle common groovy properties"},{"location":"common/gradle-common-kotlin-properties/","text":"packageName = \"com.example.db\" sourceFolders = listOf(\"db\") schemaOutputDirectory = file(\"build/dbs\") dependency(project(\":OtherProject\")) dialect = \"sqlite:3.24\"","title":"Gradle common kotlin properties"},{"location":"common/gradle-dependencies/","text":"Dependencies You can specify schema dependencies on another module: sqldelight { MyDatabase { package = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: sqldelight { MyDatabase { package = \"com.example.projectb\" } }","title":"Gradle dependencies"},{"location":"common/gradle-dependencies/#dependencies","text":"You can specify schema dependencies on another module: sqldelight { MyDatabase { package = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: sqldelight { MyDatabase { package = \"com.example.projectb\" } }","title":"Dependencies"},{"location":"common/gradle-multiplatform/","text":"Gradle For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // The dialect version you would like to target // Defaults to \"sqlite:3.18\" dialect = \"sqlite:3.24\" } // For native targets, whether sqlite should be automatically linked. // Defaults to true. linkSqlite = false } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) dialect = \"sqlite:3.24\" } linkSqlite = false } Dependencies You can specify schema dependencies on another module: sqldelight { MyDatabase { package = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: sqldelight { MyDatabase { package = \"com.example.projectb\" } }","title":"Gradle"},{"location":"common/gradle-multiplatform/#gradle","text":"For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // The dialect version you would like to target // Defaults to \"sqlite:3.18\" dialect = \"sqlite:3.24\" } // For native targets, whether sqlite should be automatically linked. // Defaults to true. linkSqlite = false } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) dialect = \"sqlite:3.24\" } linkSqlite = false }","title":"Gradle"},{"location":"common/gradle-multiplatform/#dependencies","text":"You can specify schema dependencies on another module: sqldelight { MyDatabase { package = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: sqldelight { MyDatabase { package = \"com.example.projectb\" } }","title":"Dependencies"},{"location":"common/gradle/","text":"Gradle For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // The dialect version you would like to target // Defaults to \"sqlite:3.18\" dialect = \"sqlite:3.24\" } } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) dialect = \"sqlite:3.24\" } } Dependencies You can specify schema dependencies on another module: sqldelight { MyDatabase { package = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: sqldelight { MyDatabase { package = \"com.example.projectb\" } }","title":"Gradle"},{"location":"common/gradle/#gradle","text":"For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // The dialect version you would like to target // Defaults to \"sqlite:3.18\" dialect = \"sqlite:3.24\" } } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) dialect = \"sqlite:3.24\" } }","title":"Gradle"},{"location":"common/gradle/#dependencies","text":"You can specify schema dependencies on another module: sqldelight { MyDatabase { package = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: sqldelight { MyDatabase { package = \"com.example.projectb\" } }","title":"Dependencies"},{"location":"common/gradle_server/","text":"Gradle build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"sqldelight\" , \"resources\" ] // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // Wether or not to use .sqm files as the source of truth for the schema. // Defaults to false deriveSchemaFromMigrations = true // If set, configures a task to output the .sqm migration files as valid SQL // Defaults to null migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) // The extension format to use for generated valid SQL migrations. // Defaults to \".sql\" migrationOutputFileFormat = \".sql\" } } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = [ \"sqldelight\" , \"resources\" ] dependency project ( ' : OtherProject ' ) deriveSchemaFromMigrations = true migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" } } Dependencies You can specify schema dependencies on another module: sqldelight { MyDatabase { package = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: sqldelight { MyDatabase { package = \"com.example.projectb\" } }","title":"Gradle"},{"location":"common/gradle_server/#gradle","text":"build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"sqldelight\" , \"resources\" ] // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // Wether or not to use .sqm files as the source of truth for the schema. // Defaults to false deriveSchemaFromMigrations = true // If set, configures a task to output the .sqm migration files as valid SQL // Defaults to null migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) // The extension format to use for generated valid SQL migrations. // Defaults to \".sql\" migrationOutputFileFormat = \".sql\" } } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = [ \"sqldelight\" , \"resources\" ] dependency project ( ' : OtherProject ' ) deriveSchemaFromMigrations = true migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" } }","title":"Gradle"},{"location":"common/gradle_server/#dependencies","text":"You can specify schema dependencies on another module: sqldelight { MyDatabase { package = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: sqldelight { MyDatabase { package = \"com.example.projectb\" } }","title":"Dependencies"},{"location":"common/grouping_statements/","text":"You can group multiple SQL statements together to be executed at once: upsert { UPDATE myTable SET column1 = : column1 , column2 = : column2 WHERE id = : id ; INSERT OR IGNORE INTO myTable ( id , column1 , column2 ) VALUES (: id , : column1 , : column2 ); }","title":"Grouping statements"},{"location":"common/index_gradle_database/","text":"First apply the gradle plugin in your project. buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.4.1' } } apply plugin: 'com.squareup.sqldelight' sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" } }","title":"Index gradle database"},{"location":"common/index_gradle_database_post_dialect/","text":"} } ```","title":"Index gradle database post dialect"},{"location":"common/index_gradle_database_pre_dialect/","text":"First apply the gradle plugin in your project. ```groovy buildscript { repositories { google() mavenCentral() } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.4.1' } } apply plugin: 'com.squareup.sqldelight' sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\"","title":"Index gradle database pre dialect"},{"location":"common/index_queries/","text":"SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Index queries"},{"location":"common/index_schema/","text":"Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of:","title":"Index schema"},{"location":"common/index_schema_sq/","text":"Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' );","title":"Index schema sq"},{"location":"common/index_server/","text":"SQLDelight needs to know the schema of your database. If you always create your schema fresh with create table statements, you'll want to put those statements in .sq files, as shown here . If you apply migration files to an already running database, you'll want to rename your migration files to .sqm files, as shown here Fresh Schema Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); In the same .sq files you can start placing your sql statements to be executed at runtime . Migration Schema First, configure gradle to use migrations to assemble the schema: sqldelight { Database { ... sourceFolders = [ \"sqldelight\" ] deriveSchemaFromMigrations = true } } Migration files have the extension .sqm , and must have a number in their file name indicating what order the migration file runs in. For example, given this hierarchy: src --main ----sqldelight ------v1__backend.sqm ------v2__backend.sqm SQLDelight will create the schema by applying v1__backend.sqm and then v2__backend.sqm . Place your normal SQL CREATE / ALTER statements in these files. If another service reads from your migrations files (like flyway), make sure to read the info on migrations and how to output valid SQL. Typesafe SQL Before you're able to execute SQL statements at runtime, you need to create a SqlDriver to connect to your database. The easiest way is off of a DataSource that you would get from hikari or other connection managers. dependencies { implementation \"com.squareup.sqldelight:jdbc-driver:\" } val driver : SqlDriver = dataSource . asJdbcDriver () Regardless of if you specify the schema as fresh create table statements or through migrations, runtime SQL goes in .sq files. SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Index server"},{"location":"common/index_server/#fresh-schema","text":"Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); In the same .sq files you can start placing your sql statements to be executed at runtime .","title":"Fresh Schema"},{"location":"common/index_server/#migration-schema","text":"First, configure gradle to use migrations to assemble the schema: sqldelight { Database { ... sourceFolders = [ \"sqldelight\" ] deriveSchemaFromMigrations = true } } Migration files have the extension .sqm , and must have a number in their file name indicating what order the migration file runs in. For example, given this hierarchy: src --main ----sqldelight ------v1__backend.sqm ------v2__backend.sqm SQLDelight will create the schema by applying v1__backend.sqm and then v2__backend.sqm . Place your normal SQL CREATE / ALTER statements in these files. If another service reads from your migrations files (like flyway), make sure to read the info on migrations and how to output valid SQL.","title":"Migration Schema"},{"location":"common/index_server/#typesafe-sql","text":"Before you're able to execute SQL statements at runtime, you need to create a SqlDriver to connect to your database. The easiest way is off of a DataSource that you would get from hikari or other connection managers. dependencies { implementation \"com.squareup.sqldelight:jdbc-driver:\" } val driver : SqlDriver = dataSource . asJdbcDriver () Regardless of if you specify the schema as fresh create table statements or through migrations, runtime SQL goes in .sq files. SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Typesafe SQL"},{"location":"common/intellij_plugin/","text":"IntelliJ Plugin The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight MarketplaceWidget.setupMarketplaceWidget('install', 8191, \"#intellij-plugin-button\");","title":"IntelliJ Plugin"},{"location":"common/intellij_plugin/#intellij-plugin","text":"The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight MarketplaceWidget.setupMarketplaceWidget('install', 8191, \"#intellij-plugin-button\");","title":"IntelliJ Plugin"},{"location":"common/migrations/","text":"Migrations The .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. Versioning The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; These SQL statements are run by Database.Schema.migrate() . Migration files go in the same source set as your .sq files. Verifying Migrations You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task, which is available once you specify a schemaOutputDirectory , as described in the gradle.md . You should probably do this before you create your first migration.","title":"Migrations"},{"location":"common/migrations/#migrations","text":"The .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date.","title":"Migrations"},{"location":"common/migrations/#versioning","text":"The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; These SQL statements are run by Database.Schema.migrate() . Migration files go in the same source set as your .sq files.","title":"Versioning"},{"location":"common/migrations/#verifying-migrations","text":"You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task, which is available once you specify a schemaOutputDirectory , as described in the gradle.md . You should probably do this before you create your first migration.","title":"Verifying Migrations"},{"location":"common/migrations_server/","text":"Valid SQL migrations Using custom kotlin types in migration files means those files are no longer valid SQL. You can optionally configure a gradle task to output your migration files as valid SQL for other services to read from: sqldelight { Database { migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" // Defaults to .sql } } This creates a new task generateMainDatabaseMigrations which will output your .sqm files as valid SQL in the output directory, with the output format. Create a dependency from your compileKotlin task so that services such as flyway will have the files available on their classpath: compileKotlin . configure { dependsOn \"generateMainDatabaseMigrations\" }","title":"Migrations server"},{"location":"common/migrations_server/#valid-sql-migrations","text":"Using custom kotlin types in migration files means those files are no longer valid SQL. You can optionally configure a gradle task to output your migration files as valid SQL for other services to read from: sqldelight { Database { migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" // Defaults to .sql } } This creates a new task generateMainDatabaseMigrations which will output your .sqm files as valid SQL in the output directory, with the output format. Create a dependency from your compileKotlin task so that services such as flyway will have the files available on their classpath: compileKotlin . configure { dependsOn \"generateMainDatabaseMigrations\" }","title":"Valid SQL migrations"},{"location":"common/multiplatform/","text":"Multiplatform To use SQLDelight in Kotlin multiplatform configure the Gradle plugin with a package to generate code into. apply plugin: \"org.jetbrains.kotlin.multiplatform\" apply plugin: \"com.squareup.sqldelight\" sqldelight { MyDatabase { packageName = \"com.example.hockey\" } } Put .sq files in the src/commonMain/sqldelight directory, and then expect a SqlDriver to be provided by individual platforms when creating the Database . Migration files should also be in the same src/commonMain/sqldelight directory. Multiplatform requires the gradle metadata feature , which you need to enable via the settings.gradle file in the project root: enableFeaturePreview ( 'GRADLE_METADATA' )","title":"Multiplatform"},{"location":"common/multiplatform/#multiplatform","text":"To use SQLDelight in Kotlin multiplatform configure the Gradle plugin with a package to generate code into. apply plugin: \"org.jetbrains.kotlin.multiplatform\" apply plugin: \"com.squareup.sqldelight\" sqldelight { MyDatabase { packageName = \"com.example.hockey\" } } Put .sq files in the src/commonMain/sqldelight directory, and then expect a SqlDriver to be provided by individual platforms when creating the Database . Migration files should also be in the same src/commonMain/sqldelight directory. Multiplatform requires the gradle metadata feature , which you need to enable via the settings.gradle file in the project root: enableFeaturePreview ( 'GRADLE_METADATA' )","title":"Multiplatform"},{"location":"common/query_arguments/","text":"Type Inference SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Named Arguments Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" ) Variable Arguments Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" )) Inserts INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Query arguments"},{"location":"common/query_arguments/#type-inference","text":"SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\"","title":"Type Inference"},{"location":"common/query_arguments/#named-arguments","text":"Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Named Arguments"},{"location":"common/query_arguments/#variable-arguments","text":"Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" ))","title":"Variable Arguments"},{"location":"common/query_arguments/#inserts","text":"INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Inserts"},{"location":"common/query_arguments_sqlite/","text":"Bind Args .sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments. Type Inference SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Named Arguments Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" ) Variable Arguments Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" )) Inserts INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Query arguments sqlite"},{"location":"common/query_arguments_sqlite/#bind-args","text":".sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments.","title":"Bind Args"},{"location":"common/query_arguments_sqlite/#type-inference","text":"SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\"","title":"Type Inference"},{"location":"common/query_arguments_sqlite/#named-arguments","text":"Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Named Arguments"},{"location":"common/query_arguments_sqlite/#variable-arguments","text":"Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" ))","title":"Variable Arguments"},{"location":"common/query_arguments_sqlite/#inserts","text":"INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Inserts"},{"location":"common/rxjava/","text":"RxJava To observe a query, depend on the RxJava extensions artifact and use the extension method it provides: dependencies { implementation \"com.squareup.sqldelight:rxjava3-extensions:1.4.1\" } val players : Observable < List < HockeyPlayer >> = playerQueries . selectAll () . asObservable () . mapToList () Note: For RxJava 2, use rxjava2-extensions as the artifact name.","title":"RxJava"},{"location":"common/rxjava/#rxjava","text":"To observe a query, depend on the RxJava extensions artifact and use the extension method it provides: dependencies { implementation \"com.squareup.sqldelight:rxjava3-extensions:1.4.1\" } val players : Observable < List < HockeyPlayer >> = playerQueries . selectAll () . asObservable () . mapToList () Note: For RxJava 2, use rxjava2-extensions as the artifact name.","title":"RxJava"},{"location":"common/transactions/","text":"API If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithReturn function. val players = database . playerQueries . transactionWithReturn { database . playerQueries . selectAll (). executeAsList () } Rollback Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted = database . playerQueries . transactionWithReturn { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size } Callbacks You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \"${players.size} players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"common/transactions/#api","text":"If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithReturn function. val players = database . playerQueries . transactionWithReturn { database . playerQueries . selectAll (). executeAsList () }","title":"API"},{"location":"common/transactions/#rollback","text":"Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted = database . playerQueries . transactionWithReturn { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size }","title":"Rollback"},{"location":"common/transactions/#callbacks","text":"You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \"${players.size} players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Callbacks"},{"location":"common/types_server_migrations/","text":"Custom Types in Migrations If migrations are the schema's source of truth, you can also specify the exposed kotlin type when altering a table: import kotlin . collection . List ; ALTER TABLE my_table ADD COLUMN new_column VARCHAR ( 8 ) AS List < String > ;","title":"Types server migrations"},{"location":"common/types_server_migrations/#custom-types-in-migrations","text":"If migrations are the schema's source of truth, you can also specify the exposed kotlin type when altering a table: import kotlin . collection . List ; ALTER TABLE my_table ADD COLUMN new_column VARCHAR ( 8 ) AS List < String > ;","title":"Custom Types in Migrations"},{"location":"common/types_sqlite/","text":"SQLite Types SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. SQLDelight natively supports Long, Double, String, ByteArray, Int, Short, Float, and Booleans. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray some_int INTEGER AS Int , -- Stored as INTEGER in db, retrieved as Int some_short INTEGER AS Short , -- Stored as INTEGER in db, retrieved as Short some_float REAL AS Float -- Stored as REAL in db, retrieved as Float ); Boolean columns are stored in the db as INTEGER , and so they can be given INTEGER column constraints. Use DEFAULT 0 to default to false, for example. CREATE TABLE hockey_player ( injured INTEGER AS Boolean DEFAULT 0 )","title":"Types sqlite"},{"location":"common/types_sqlite/#sqlite-types","text":"SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. SQLDelight natively supports Long, Double, String, ByteArray, Int, Short, Float, and Booleans. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray some_int INTEGER AS Int , -- Stored as INTEGER in db, retrieved as Int some_short INTEGER AS Short , -- Stored as INTEGER in db, retrieved as Short some_float REAL AS Float -- Stored as REAL in db, retrieved as Float ); Boolean columns are stored in the db as INTEGER , and so they can be given INTEGER column constraints. Use DEFAULT 0 to default to false, for example. CREATE TABLE hockey_player ( injured INTEGER AS Boolean DEFAULT 0 )","title":"SQLite Types"},{"location":"jvm_h2/","text":"\ud83d\udc77\u200d\u2640\ufe0f IN DEVELOPMENT H2 is still incubating, and pieces of the dialect are missing. If you are using it and encounter parts of the dialect which are unsupported, please report at sql-psi Getting Started with H2 First apply the gradle plugin in your project. buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.4.1' } } apply plugin: 'com.squareup.sqldelight' sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" dialect = \"hsql\" } } SQLDelight needs to know the schema of your database. If you always create your schema fresh with create table statements, you'll want to put those statements in .sq files, as shown here . If you apply migration files to an already running database, you'll want to rename your migration files to .sqm files, as shown here Fresh Schema Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); In the same .sq files you can start placing your sql statements to be executed at runtime . Migration Schema First, configure gradle to use migrations to assemble the schema: sqldelight { Database { ... sourceFolders = [ \"sqldelight\" ] deriveSchemaFromMigrations = true } } Migration files have the extension .sqm , and must have a number in their file name indicating what order the migration file runs in. For example, given this hierarchy: src --main ----sqldelight ------v1__backend.sqm ------v2__backend.sqm SQLDelight will create the schema by applying v1__backend.sqm and then v2__backend.sqm . Place your normal SQL CREATE / ALTER statements in these files. If another service reads from your migrations files (like flyway), make sure to read the info on migrations and how to output valid SQL. Typesafe SQL Before you're able to execute SQL statements at runtime, you need to create a SqlDriver to connect to your database. The easiest way is off of a DataSource that you would get from hikari or other connection managers. dependencies { implementation \"com.squareup.sqldelight:jdbc-driver:\" } val driver : SqlDriver = dataSource . asJdbcDriver () Regardless of if you specify the schema as fresh create table statements or through migrations, runtime SQL goes in .sq files. SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Getting Started"},{"location":"jvm_h2/#in-development","text":"H2 is still incubating, and pieces of the dialect are missing. If you are using it and encounter parts of the dialect which are unsupported, please report at sql-psi","title":"\ud83d\udc77\u200d\u2640\ufe0f IN DEVELOPMENT"},{"location":"jvm_h2/#getting-started-with-h2","text":"First apply the gradle plugin in your project. buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.4.1' } } apply plugin: 'com.squareup.sqldelight' sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" dialect = \"hsql\" } } SQLDelight needs to know the schema of your database. If you always create your schema fresh with create table statements, you'll want to put those statements in .sq files, as shown here . If you apply migration files to an already running database, you'll want to rename your migration files to .sqm files, as shown here","title":"Getting Started with H2"},{"location":"jvm_h2/#fresh-schema","text":"Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); In the same .sq files you can start placing your sql statements to be executed at runtime .","title":"Fresh Schema"},{"location":"jvm_h2/#migration-schema","text":"First, configure gradle to use migrations to assemble the schema: sqldelight { Database { ... sourceFolders = [ \"sqldelight\" ] deriveSchemaFromMigrations = true } } Migration files have the extension .sqm , and must have a number in their file name indicating what order the migration file runs in. For example, given this hierarchy: src --main ----sqldelight ------v1__backend.sqm ------v2__backend.sqm SQLDelight will create the schema by applying v1__backend.sqm and then v2__backend.sqm . Place your normal SQL CREATE / ALTER statements in these files. If another service reads from your migrations files (like flyway), make sure to read the info on migrations and how to output valid SQL.","title":"Migration Schema"},{"location":"jvm_h2/#typesafe-sql","text":"Before you're able to execute SQL statements at runtime, you need to create a SqlDriver to connect to your database. The easiest way is off of a DataSource that you would get from hikari or other connection managers. dependencies { implementation \"com.squareup.sqldelight:jdbc-driver:\" } val driver : SqlDriver = dataSource . asJdbcDriver () Regardless of if you specify the schema as fresh create table statements or through migrations, runtime SQL goes in .sq files. SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Typesafe SQL"},{"location":"jvm_h2/custom_projections/","text":"Projections By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"jvm_h2/custom_projections/#projections","text":"By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"jvm_h2/gradle/","text":"Gradle build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"sqldelight\" , \"resources\" ] // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // Wether or not to use .sqm files as the source of truth for the schema. // Defaults to false deriveSchemaFromMigrations = true // If set, configures a task to output the .sqm migration files as valid SQL // Defaults to null migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) // The extension format to use for generated valid SQL migrations. // Defaults to \".sql\" migrationOutputFileFormat = \".sql\" } } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = [ \"sqldelight\" , \"resources\" ] dependency project ( ' : OtherProject ' ) deriveSchemaFromMigrations = true migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" } } Dependencies You can specify schema dependencies on another module: sqldelight { MyDatabase { package = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: sqldelight { MyDatabase { package = \"com.example.projectb\" } }","title":"Gradle"},{"location":"jvm_h2/gradle/#gradle","text":"build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"sqldelight\" , \"resources\" ] // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // Wether or not to use .sqm files as the source of truth for the schema. // Defaults to false deriveSchemaFromMigrations = true // If set, configures a task to output the .sqm migration files as valid SQL // Defaults to null migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) // The extension format to use for generated valid SQL migrations. // Defaults to \".sql\" migrationOutputFileFormat = \".sql\" } } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = [ \"sqldelight\" , \"resources\" ] dependency project ( ' : OtherProject ' ) deriveSchemaFromMigrations = true migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" } }","title":"Gradle"},{"location":"jvm_h2/gradle/#dependencies","text":"You can specify schema dependencies on another module: sqldelight { MyDatabase { package = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: sqldelight { MyDatabase { package = \"com.example.projectb\" } }","title":"Dependencies"},{"location":"jvm_h2/grouping_statements/","text":"You can group multiple SQL statements together to be executed at once: upsert { UPDATE myTable SET column1 = : column1 , column2 = : column2 WHERE id = : id ; INSERT OR IGNORE INTO myTable ( id , column1 , column2 ) VALUES (: id , : column1 , : column2 ); }","title":"Grouping Statements"},{"location":"jvm_h2/intellij_plugin/","text":"IntelliJ Plugin The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight MarketplaceWidget.setupMarketplaceWidget('install', 8191, \"#intellij-plugin-button\");","title":"IntelliJ Plugin"},{"location":"jvm_h2/intellij_plugin/#intellij-plugin","text":"The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight MarketplaceWidget.setupMarketplaceWidget('install', 8191, \"#intellij-plugin-button\");","title":"IntelliJ Plugin"},{"location":"jvm_h2/migrations/","text":"Valid SQL migrations Using custom kotlin types in migration files means those files are no longer valid SQL. You can optionally configure a gradle task to output your migration files as valid SQL for other services to read from: sqldelight { Database { migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" // Defaults to .sql } } This creates a new task generateMainDatabaseMigrations which will output your .sqm files as valid SQL in the output directory, with the output format. Create a dependency from your compileKotlin task so that services such as flyway will have the files available on their classpath: compileKotlin . configure { dependsOn \"generateMainDatabaseMigrations\" }","title":"Migrations"},{"location":"jvm_h2/migrations/#valid-sql-migrations","text":"Using custom kotlin types in migration files means those files are no longer valid SQL. You can optionally configure a gradle task to output your migration files as valid SQL for other services to read from: sqldelight { Database { migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" // Defaults to .sql } } This creates a new task generateMainDatabaseMigrations which will output your .sqm files as valid SQL in the output directory, with the output format. Create a dependency from your compileKotlin task so that services such as flyway will have the files available on their classpath: compileKotlin . configure { dependsOn \"generateMainDatabaseMigrations\" }","title":"Valid SQL migrations"},{"location":"jvm_h2/query_arguments/","text":"Bind Args .sq files use the exact same syntax as MySQL, including bound arguments. If a statement contains bind args, the associated method will require corresponding arguments. Type Inference SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Named Arguments Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" ) Variable Arguments Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" )) Inserts INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Arguments"},{"location":"jvm_h2/query_arguments/#bind-args","text":".sq files use the exact same syntax as MySQL, including bound arguments. If a statement contains bind args, the associated method will require corresponding arguments.","title":"Bind Args"},{"location":"jvm_h2/query_arguments/#type-inference","text":"SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\"","title":"Type Inference"},{"location":"jvm_h2/query_arguments/#named-arguments","text":"Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Named Arguments"},{"location":"jvm_h2/query_arguments/#variable-arguments","text":"Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" ))","title":"Variable Arguments"},{"location":"jvm_h2/query_arguments/#inserts","text":"INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Inserts"},{"location":"jvm_h2/transactions/","text":"API If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithReturn function. val players = database . playerQueries . transactionWithReturn { database . playerQueries . selectAll (). executeAsList () } Rollback Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted = database . playerQueries . transactionWithReturn { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size } Callbacks You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \"${players.size} players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"jvm_h2/transactions/#api","text":"If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithReturn function. val players = database . playerQueries . transactionWithReturn { database . playerQueries . selectAll (). executeAsList () }","title":"API"},{"location":"jvm_h2/transactions/#rollback","text":"Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted = database . playerQueries . transactionWithReturn { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size }","title":"Rollback"},{"location":"jvm_h2/transactions/#callbacks","text":"You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \"${players.size} players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Callbacks"},{"location":"jvm_h2/types/","text":"MySQL Types SQLDelight column definitions are identical to regular H2 column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. CREATE TABLE some_types ( some_tiny_int TINYINT , -- Retrieved as Int some_small_int SMALLINT , -- Retrieved as Int some_integer INTEGER , -- Retrieved as Int some_int INT , -- Retrieved as Int some_big_int BIGINT , -- Retrieved as Long some_decimal DECIMAL ( 6 , 5 ), -- Retrieved as Int some_dec DEC ( 6 , 5 ), -- Retrieved as Int some_numeric NUMERIC ( 6 , 5 ), -- Retrieved as Int some_float FLOAT ( 6 ), -- Retrieved as Double some_real REAL , -- Retrieved as Double some_double DOUBLE , -- Retrieved as Double some_double_precision DOUBLE PRECISION , -- Retrieved as Double some_boolean BOOLEAN , -- Retrieved as Boolean some_date DATE , -- Retrieved as String some_time TIME , -- Retrieved as String some_timestamp2 TIMESTAMP ( 6 ), -- Retrieved as String some_char CHAR , -- Retrieved as String some_character CHARACTER ( 6 ), -- Retrieved as String some_char_varying CHAR VARYING ( 6 ), -- Retrieved as String some_longvarchar LONGVARCHAR , -- Retrieved as String some_character_varying CHARACTER VARYING ( 6 ), -- Retrieved as String some_varchar VARCHAR ( 16 ), -- Retrieved as String some_clo CHARACTER LARGE OBJECT ( 16 ), -- Retrieved as String some_clob clob ( 16 M CHARACTERS ), -- Retrieved as String some_binary BINARY , -- Retrieved as ByteArray some_binary2 BINARY ( 6 ), -- Retrieved as ByteArray some_longvarbinary LONGVARBINARY , -- Retrieved as ByteArray some_longvarbinary2 LONGVARBINARY ( 6 ), -- Retrieved as ByteArray some_binary_varying BINARY VARYING ( 6 ), -- Retrieved as ByteArray some_varbinary VARBINARY ( 8 ), -- Retrieved as ByteArray some_uuid UUID , -- Retrieved as ByteArray some_blob BLOB , -- Retrieved as ByteArray some_blo BINARY LARGE OBJECT ( 6 ), -- Retrieved as ByteArray some_bit BIT , -- Retrieved as ByteArray some_bit2 BIT ( 6 ), -- Retrieved as ByteArray some_bit_varying BIT VARYING ( 6 ), -- Retrieved as ByteArray some_interval INTERVAL YEAR TO MONTH , -- Retrieved as ByteArray some_interval2 INTERVAL YEAR ( 3 ), -- Retrieved as ByteArray some_interval3 INTERVAL DAY ( 4 ) TO HOUR , -- Retrieved as ByteArray some_interval4 INTERVAL MINUTE ( 4 ) TO SECOND ( 6 ), -- Retrieved as ByteArray some_interval5 INTERVAL SECOND ( 4 , 6 ) -- Retrieved as ByteArray ); Custom Column Types If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) ) Enums As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) ) Custom Types in Migrations If migrations are the schema's source of truth, you can also specify the exposed kotlin type when altering a table: import kotlin . collection . List ; ALTER TABLE my_table ADD COLUMN new_column VARCHAR ( 8 ) AS List < String > ;","title":"Types"},{"location":"jvm_h2/types/#mysql-types","text":"SQLDelight column definitions are identical to regular H2 column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. CREATE TABLE some_types ( some_tiny_int TINYINT , -- Retrieved as Int some_small_int SMALLINT , -- Retrieved as Int some_integer INTEGER , -- Retrieved as Int some_int INT , -- Retrieved as Int some_big_int BIGINT , -- Retrieved as Long some_decimal DECIMAL ( 6 , 5 ), -- Retrieved as Int some_dec DEC ( 6 , 5 ), -- Retrieved as Int some_numeric NUMERIC ( 6 , 5 ), -- Retrieved as Int some_float FLOAT ( 6 ), -- Retrieved as Double some_real REAL , -- Retrieved as Double some_double DOUBLE , -- Retrieved as Double some_double_precision DOUBLE PRECISION , -- Retrieved as Double some_boolean BOOLEAN , -- Retrieved as Boolean some_date DATE , -- Retrieved as String some_time TIME , -- Retrieved as String some_timestamp2 TIMESTAMP ( 6 ), -- Retrieved as String some_char CHAR , -- Retrieved as String some_character CHARACTER ( 6 ), -- Retrieved as String some_char_varying CHAR VARYING ( 6 ), -- Retrieved as String some_longvarchar LONGVARCHAR , -- Retrieved as String some_character_varying CHARACTER VARYING ( 6 ), -- Retrieved as String some_varchar VARCHAR ( 16 ), -- Retrieved as String some_clo CHARACTER LARGE OBJECT ( 16 ), -- Retrieved as String some_clob clob ( 16 M CHARACTERS ), -- Retrieved as String some_binary BINARY , -- Retrieved as ByteArray some_binary2 BINARY ( 6 ), -- Retrieved as ByteArray some_longvarbinary LONGVARBINARY , -- Retrieved as ByteArray some_longvarbinary2 LONGVARBINARY ( 6 ), -- Retrieved as ByteArray some_binary_varying BINARY VARYING ( 6 ), -- Retrieved as ByteArray some_varbinary VARBINARY ( 8 ), -- Retrieved as ByteArray some_uuid UUID , -- Retrieved as ByteArray some_blob BLOB , -- Retrieved as ByteArray some_blo BINARY LARGE OBJECT ( 6 ), -- Retrieved as ByteArray some_bit BIT , -- Retrieved as ByteArray some_bit2 BIT ( 6 ), -- Retrieved as ByteArray some_bit_varying BIT VARYING ( 6 ), -- Retrieved as ByteArray some_interval INTERVAL YEAR TO MONTH , -- Retrieved as ByteArray some_interval2 INTERVAL YEAR ( 3 ), -- Retrieved as ByteArray some_interval3 INTERVAL DAY ( 4 ) TO HOUR , -- Retrieved as ByteArray some_interval4 INTERVAL MINUTE ( 4 ) TO SECOND ( 6 ), -- Retrieved as ByteArray some_interval5 INTERVAL SECOND ( 4 , 6 ) -- Retrieved as ByteArray );","title":"MySQL Types"},{"location":"jvm_h2/types/#custom-column-types","text":"If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) )","title":"Custom Column Types"},{"location":"jvm_h2/types/#enums","text":"As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Enums"},{"location":"jvm_h2/types/#custom-types-in-migrations","text":"If migrations are the schema's source of truth, you can also specify the exposed kotlin type when altering a table: import kotlin . collection . List ; ALTER TABLE my_table ADD COLUMN new_column VARCHAR ( 8 ) AS List < String > ;","title":"Custom Types in Migrations"},{"location":"jvm_mysql/","text":"Getting Started with MySQL First apply the gradle plugin in your project. buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.4.1' } } apply plugin: 'com.squareup.sqldelight' sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" dialect = \"mysql\" } } SQLDelight needs to know the schema of your database. If you always create your schema fresh with create table statements, you'll want to put those statements in .sq files, as shown here . If you apply migration files to an already running database, you'll want to rename your migration files to .sqm files, as shown here Fresh Schema Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); In the same .sq files you can start placing your sql statements to be executed at runtime . Migration Schema First, configure gradle to use migrations to assemble the schema: sqldelight { Database { ... sourceFolders = [ \"sqldelight\" ] deriveSchemaFromMigrations = true } } Migration files have the extension .sqm , and must have a number in their file name indicating what order the migration file runs in. For example, given this hierarchy: src --main ----sqldelight ------v1__backend.sqm ------v2__backend.sqm SQLDelight will create the schema by applying v1__backend.sqm and then v2__backend.sqm . Place your normal SQL CREATE / ALTER statements in these files. If another service reads from your migrations files (like flyway), make sure to read the info on migrations and how to output valid SQL. Typesafe SQL Before you're able to execute SQL statements at runtime, you need to create a SqlDriver to connect to your database. The easiest way is off of a DataSource that you would get from hikari or other connection managers. dependencies { implementation \"com.squareup.sqldelight:jdbc-driver:\" } val driver : SqlDriver = dataSource . asJdbcDriver () Regardless of if you specify the schema as fresh create table statements or through migrations, runtime SQL goes in .sq files. SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Getting Started"},{"location":"jvm_mysql/#getting-started-with-mysql","text":"First apply the gradle plugin in your project. buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.4.1' } } apply plugin: 'com.squareup.sqldelight' sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" dialect = \"mysql\" } } SQLDelight needs to know the schema of your database. If you always create your schema fresh with create table statements, you'll want to put those statements in .sq files, as shown here . If you apply migration files to an already running database, you'll want to rename your migration files to .sqm files, as shown here","title":"Getting Started with MySQL"},{"location":"jvm_mysql/#fresh-schema","text":"Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); In the same .sq files you can start placing your sql statements to be executed at runtime .","title":"Fresh Schema"},{"location":"jvm_mysql/#migration-schema","text":"First, configure gradle to use migrations to assemble the schema: sqldelight { Database { ... sourceFolders = [ \"sqldelight\" ] deriveSchemaFromMigrations = true } } Migration files have the extension .sqm , and must have a number in their file name indicating what order the migration file runs in. For example, given this hierarchy: src --main ----sqldelight ------v1__backend.sqm ------v2__backend.sqm SQLDelight will create the schema by applying v1__backend.sqm and then v2__backend.sqm . Place your normal SQL CREATE / ALTER statements in these files. If another service reads from your migrations files (like flyway), make sure to read the info on migrations and how to output valid SQL.","title":"Migration Schema"},{"location":"jvm_mysql/#typesafe-sql","text":"Before you're able to execute SQL statements at runtime, you need to create a SqlDriver to connect to your database. The easiest way is off of a DataSource that you would get from hikari or other connection managers. dependencies { implementation \"com.squareup.sqldelight:jdbc-driver:\" } val driver : SqlDriver = dataSource . asJdbcDriver () Regardless of if you specify the schema as fresh create table statements or through migrations, runtime SQL goes in .sq files. SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Typesafe SQL"},{"location":"jvm_mysql/custom_projections/","text":"Projections By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"jvm_mysql/custom_projections/#projections","text":"By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"jvm_mysql/gradle/","text":"Gradle build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"sqldelight\" , \"resources\" ] // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // Wether or not to use .sqm files as the source of truth for the schema. // Defaults to false deriveSchemaFromMigrations = true // If set, configures a task to output the .sqm migration files as valid SQL // Defaults to null migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) // The extension format to use for generated valid SQL migrations. // Defaults to \".sql\" migrationOutputFileFormat = \".sql\" } } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = [ \"sqldelight\" , \"resources\" ] dependency project ( ' : OtherProject ' ) deriveSchemaFromMigrations = true migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" } } Dependencies You can specify schema dependencies on another module: sqldelight { MyDatabase { package = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: sqldelight { MyDatabase { package = \"com.example.projectb\" } }","title":"Gradle"},{"location":"jvm_mysql/gradle/#gradle","text":"build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"sqldelight\" , \"resources\" ] // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // Wether or not to use .sqm files as the source of truth for the schema. // Defaults to false deriveSchemaFromMigrations = true // If set, configures a task to output the .sqm migration files as valid SQL // Defaults to null migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) // The extension format to use for generated valid SQL migrations. // Defaults to \".sql\" migrationOutputFileFormat = \".sql\" } } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = [ \"sqldelight\" , \"resources\" ] dependency project ( ' : OtherProject ' ) deriveSchemaFromMigrations = true migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" } }","title":"Gradle"},{"location":"jvm_mysql/gradle/#dependencies","text":"You can specify schema dependencies on another module: sqldelight { MyDatabase { package = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: sqldelight { MyDatabase { package = \"com.example.projectb\" } }","title":"Dependencies"},{"location":"jvm_mysql/grouping_statements/","text":"You can group multiple SQL statements together to be executed at once: upsert { UPDATE myTable SET column1 = : column1 , column2 = : column2 WHERE id = : id ; INSERT OR IGNORE INTO myTable ( id , column1 , column2 ) VALUES (: id , : column1 , : column2 ); }","title":"Grouping Statements"},{"location":"jvm_mysql/intellij_plugin/","text":"IntelliJ Plugin The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight MarketplaceWidget.setupMarketplaceWidget('install', 8191, \"#intellij-plugin-button\");","title":"IntelliJ Plugin"},{"location":"jvm_mysql/intellij_plugin/#intellij-plugin","text":"The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight MarketplaceWidget.setupMarketplaceWidget('install', 8191, \"#intellij-plugin-button\");","title":"IntelliJ Plugin"},{"location":"jvm_mysql/migrations/","text":"Valid SQL migrations Using custom kotlin types in migration files means those files are no longer valid SQL. You can optionally configure a gradle task to output your migration files as valid SQL for other services to read from: sqldelight { Database { migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" // Defaults to .sql } } This creates a new task generateMainDatabaseMigrations which will output your .sqm files as valid SQL in the output directory, with the output format. Create a dependency from your compileKotlin task so that services such as flyway will have the files available on their classpath: compileKotlin . configure { dependsOn \"generateMainDatabaseMigrations\" }","title":"Migrations"},{"location":"jvm_mysql/migrations/#valid-sql-migrations","text":"Using custom kotlin types in migration files means those files are no longer valid SQL. You can optionally configure a gradle task to output your migration files as valid SQL for other services to read from: sqldelight { Database { migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" // Defaults to .sql } } This creates a new task generateMainDatabaseMigrations which will output your .sqm files as valid SQL in the output directory, with the output format. Create a dependency from your compileKotlin task so that services such as flyway will have the files available on their classpath: compileKotlin . configure { dependsOn \"generateMainDatabaseMigrations\" }","title":"Valid SQL migrations"},{"location":"jvm_mysql/query_arguments/","text":"Bind Args .sq files use the exact same syntax as MySQL, including bound arguments. If a statement contains bind args, the associated method will require corresponding arguments. Type Inference SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Named Arguments Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" ) Variable Arguments Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" )) Inserts INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Arguments"},{"location":"jvm_mysql/query_arguments/#bind-args","text":".sq files use the exact same syntax as MySQL, including bound arguments. If a statement contains bind args, the associated method will require corresponding arguments.","title":"Bind Args"},{"location":"jvm_mysql/query_arguments/#type-inference","text":"SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\"","title":"Type Inference"},{"location":"jvm_mysql/query_arguments/#named-arguments","text":"Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Named Arguments"},{"location":"jvm_mysql/query_arguments/#variable-arguments","text":"Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" ))","title":"Variable Arguments"},{"location":"jvm_mysql/query_arguments/#inserts","text":"INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Inserts"},{"location":"jvm_mysql/transactions/","text":"API If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithReturn function. val players = database . playerQueries . transactionWithReturn { database . playerQueries . selectAll (). executeAsList () } Rollback Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted = database . playerQueries . transactionWithReturn { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size } Callbacks You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \"${players.size} players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"jvm_mysql/transactions/#api","text":"If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithReturn function. val players = database . playerQueries . transactionWithReturn { database . playerQueries . selectAll (). executeAsList () }","title":"API"},{"location":"jvm_mysql/transactions/#rollback","text":"Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted = database . playerQueries . transactionWithReturn { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size }","title":"Rollback"},{"location":"jvm_mysql/transactions/#callbacks","text":"You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \"${players.size} players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Callbacks"},{"location":"jvm_mysql/types/","text":"MySQL Types SQLDelight column definitions are identical to regular MySQL column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. CREATE TABLE some_types ( some_tiny_int TINYINT , -- Retrieved as Int some_small_int SMALLINT , -- Retrieved as Int some_medium_int MEDIUMINT , -- Retrieved as Int some_integer INTEGER , -- Retrieved as Int some_int INT , -- Retrieved as Int some_big_int BIGINT , -- Retrieved as Long some_decimal DECIMAL , -- Retrieved as Double some_dec DEC , -- Retrieved as Double some_fixed FIXED , -- Retrieved as Double some_numeric NUMERIC , -- Retrieved as Double some_float FLOAT , -- Retrieved as Double some_real REAL , -- Retrieved as Double some_double_prec DOUBLE PRECISION , -- Retrieved as Double some_double DOUBLE , -- Retrieved as Double some_date DATE , -- Retrieved as String some_time TIME , -- Retrieved as String some_datetime DATETIME , -- Retrieved as String some_timestamp TIMESTAMP , -- Retrieved as String some_year YEAR , -- Retrieved as String some_char CHAR , -- Retrieved as String some_varchar VARCHAR ( 16 ), -- Retrieved as String some_tiny_text TINYTEXT , -- Retrieved as String some_text TEXT , -- Retrieved as String some_medium_text MEDIUMTEXT , -- Retrieved as String some_long_text LONGTEXT , -- Retrieved as String some_enum ENUM , -- Retrieved as String some_set SET , -- Retrieved as String some_varbinary VARBINARY ( 8 ), -- Retrieved as ByteArray some_blob BLOB ( 8 , 8 ), -- Retrieved as ByteArray some_binary BINARY , -- Retrieved as ByteArray some_json JSON , -- Retrieved as String some_boolean BOOLEAN , -- Retrieved as Boolean ); Custom Column Types If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) ) Enums As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) ) Custom Types in Migrations If migrations are the schema's source of truth, you can also specify the exposed kotlin type when altering a table: import kotlin . collection . List ; ALTER TABLE my_table ADD COLUMN new_column VARCHAR ( 8 ) AS List < String > ;","title":"Types"},{"location":"jvm_mysql/types/#mysql-types","text":"SQLDelight column definitions are identical to regular MySQL column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. CREATE TABLE some_types ( some_tiny_int TINYINT , -- Retrieved as Int some_small_int SMALLINT , -- Retrieved as Int some_medium_int MEDIUMINT , -- Retrieved as Int some_integer INTEGER , -- Retrieved as Int some_int INT , -- Retrieved as Int some_big_int BIGINT , -- Retrieved as Long some_decimal DECIMAL , -- Retrieved as Double some_dec DEC , -- Retrieved as Double some_fixed FIXED , -- Retrieved as Double some_numeric NUMERIC , -- Retrieved as Double some_float FLOAT , -- Retrieved as Double some_real REAL , -- Retrieved as Double some_double_prec DOUBLE PRECISION , -- Retrieved as Double some_double DOUBLE , -- Retrieved as Double some_date DATE , -- Retrieved as String some_time TIME , -- Retrieved as String some_datetime DATETIME , -- Retrieved as String some_timestamp TIMESTAMP , -- Retrieved as String some_year YEAR , -- Retrieved as String some_char CHAR , -- Retrieved as String some_varchar VARCHAR ( 16 ), -- Retrieved as String some_tiny_text TINYTEXT , -- Retrieved as String some_text TEXT , -- Retrieved as String some_medium_text MEDIUMTEXT , -- Retrieved as String some_long_text LONGTEXT , -- Retrieved as String some_enum ENUM , -- Retrieved as String some_set SET , -- Retrieved as String some_varbinary VARBINARY ( 8 ), -- Retrieved as ByteArray some_blob BLOB ( 8 , 8 ), -- Retrieved as ByteArray some_binary BINARY , -- Retrieved as ByteArray some_json JSON , -- Retrieved as String some_boolean BOOLEAN , -- Retrieved as Boolean );","title":"MySQL Types"},{"location":"jvm_mysql/types/#custom-column-types","text":"If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) )","title":"Custom Column Types"},{"location":"jvm_mysql/types/#enums","text":"As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Enums"},{"location":"jvm_mysql/types/#custom-types-in-migrations","text":"If migrations are the schema's source of truth, you can also specify the exposed kotlin type when altering a table: import kotlin . collection . List ; ALTER TABLE my_table ADD COLUMN new_column VARCHAR ( 8 ) AS List < String > ;","title":"Custom Types in Migrations"},{"location":"jvm_postgresql/","text":"\ud83d\udc77\u200d\u2640\ufe0f IN DEVELOPMENT PostgreSQL is still incubating, and pieces of the dialect are missing. If you are using it and encounter parts of the dialect which are unsupported, please report at sql-psi Getting Started with PostgreSQL First apply the gradle plugin in your project. buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.4.1' } } apply plugin: 'com.squareup.sqldelight' sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" dialect = \"postgresql\" } } SQLDelight needs to know the schema of your database. If you always create your schema fresh with create table statements, you'll want to put those statements in .sq files, as shown here . If you apply migration files to an already running database, you'll want to rename your migration files to .sqm files, as shown here Fresh Schema Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); In the same .sq files you can start placing your sql statements to be executed at runtime . Migration Schema First, configure gradle to use migrations to assemble the schema: sqldelight { Database { ... sourceFolders = [ \"sqldelight\" ] deriveSchemaFromMigrations = true } } Migration files have the extension .sqm , and must have a number in their file name indicating what order the migration file runs in. For example, given this hierarchy: src --main ----sqldelight ------v1__backend.sqm ------v2__backend.sqm SQLDelight will create the schema by applying v1__backend.sqm and then v2__backend.sqm . Place your normal SQL CREATE / ALTER statements in these files. If another service reads from your migrations files (like flyway), make sure to read the info on migrations and how to output valid SQL. Typesafe SQL Before you're able to execute SQL statements at runtime, you need to create a SqlDriver to connect to your database. The easiest way is off of a DataSource that you would get from hikari or other connection managers. dependencies { implementation \"com.squareup.sqldelight:jdbc-driver:\" } val driver : SqlDriver = dataSource . asJdbcDriver () Regardless of if you specify the schema as fresh create table statements or through migrations, runtime SQL goes in .sq files. SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Getting Started"},{"location":"jvm_postgresql/#in-development","text":"PostgreSQL is still incubating, and pieces of the dialect are missing. If you are using it and encounter parts of the dialect which are unsupported, please report at sql-psi","title":"\ud83d\udc77\u200d\u2640\ufe0f IN DEVELOPMENT"},{"location":"jvm_postgresql/#getting-started-with-postgresql","text":"First apply the gradle plugin in your project. buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.4.1' } } apply plugin: 'com.squareup.sqldelight' sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" dialect = \"postgresql\" } } SQLDelight needs to know the schema of your database. If you always create your schema fresh with create table statements, you'll want to put those statements in .sq files, as shown here . If you apply migration files to an already running database, you'll want to rename your migration files to .sqm files, as shown here","title":"Getting Started with PostgreSQL"},{"location":"jvm_postgresql/#fresh-schema","text":"Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); In the same .sq files you can start placing your sql statements to be executed at runtime .","title":"Fresh Schema"},{"location":"jvm_postgresql/#migration-schema","text":"First, configure gradle to use migrations to assemble the schema: sqldelight { Database { ... sourceFolders = [ \"sqldelight\" ] deriveSchemaFromMigrations = true } } Migration files have the extension .sqm , and must have a number in their file name indicating what order the migration file runs in. For example, given this hierarchy: src --main ----sqldelight ------v1__backend.sqm ------v2__backend.sqm SQLDelight will create the schema by applying v1__backend.sqm and then v2__backend.sqm . Place your normal SQL CREATE / ALTER statements in these files. If another service reads from your migrations files (like flyway), make sure to read the info on migrations and how to output valid SQL.","title":"Migration Schema"},{"location":"jvm_postgresql/#typesafe-sql","text":"Before you're able to execute SQL statements at runtime, you need to create a SqlDriver to connect to your database. The easiest way is off of a DataSource that you would get from hikari or other connection managers. dependencies { implementation \"com.squareup.sqldelight:jdbc-driver:\" } val driver : SqlDriver = dataSource . asJdbcDriver () Regardless of if you specify the schema as fresh create table statements or through migrations, runtime SQL goes in .sq files. SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Typesafe SQL"},{"location":"jvm_postgresql/custom_projections/","text":"Projections By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"jvm_postgresql/custom_projections/#projections","text":"By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"jvm_postgresql/gradle/","text":"Gradle build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"sqldelight\" , \"resources\" ] // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // Wether or not to use .sqm files as the source of truth for the schema. // Defaults to false deriveSchemaFromMigrations = true // If set, configures a task to output the .sqm migration files as valid SQL // Defaults to null migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) // The extension format to use for generated valid SQL migrations. // Defaults to \".sql\" migrationOutputFileFormat = \".sql\" } } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = [ \"sqldelight\" , \"resources\" ] dependency project ( ' : OtherProject ' ) deriveSchemaFromMigrations = true migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" } } Dependencies You can specify schema dependencies on another module: sqldelight { MyDatabase { package = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: sqldelight { MyDatabase { package = \"com.example.projectb\" } }","title":"Gradle"},{"location":"jvm_postgresql/gradle/#gradle","text":"build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"sqldelight\" , \"resources\" ] // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // Wether or not to use .sqm files as the source of truth for the schema. // Defaults to false deriveSchemaFromMigrations = true // If set, configures a task to output the .sqm migration files as valid SQL // Defaults to null migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) // The extension format to use for generated valid SQL migrations. // Defaults to \".sql\" migrationOutputFileFormat = \".sql\" } } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = [ \"sqldelight\" , \"resources\" ] dependency project ( ' : OtherProject ' ) deriveSchemaFromMigrations = true migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" } }","title":"Gradle"},{"location":"jvm_postgresql/gradle/#dependencies","text":"You can specify schema dependencies on another module: sqldelight { MyDatabase { package = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: sqldelight { MyDatabase { package = \"com.example.projectb\" } }","title":"Dependencies"},{"location":"jvm_postgresql/grouping_statements/","text":"You can group multiple SQL statements together to be executed at once: upsert { UPDATE myTable SET column1 = : column1 , column2 = : column2 WHERE id = : id ; INSERT OR IGNORE INTO myTable ( id , column1 , column2 ) VALUES (: id , : column1 , : column2 ); }","title":"Grouping Statements"},{"location":"jvm_postgresql/intellij_plugin/","text":"IntelliJ Plugin The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight MarketplaceWidget.setupMarketplaceWidget('install', 8191, \"#intellij-plugin-button\");","title":"IntelliJ Plugin"},{"location":"jvm_postgresql/intellij_plugin/#intellij-plugin","text":"The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight MarketplaceWidget.setupMarketplaceWidget('install', 8191, \"#intellij-plugin-button\");","title":"IntelliJ Plugin"},{"location":"jvm_postgresql/migrations/","text":"Valid SQL migrations Using custom kotlin types in migration files means those files are no longer valid SQL. You can optionally configure a gradle task to output your migration files as valid SQL for other services to read from: sqldelight { Database { migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" // Defaults to .sql } } This creates a new task generateMainDatabaseMigrations which will output your .sqm files as valid SQL in the output directory, with the output format. Create a dependency from your compileKotlin task so that services such as flyway will have the files available on their classpath: compileKotlin . configure { dependsOn \"generateMainDatabaseMigrations\" }","title":"Migrations"},{"location":"jvm_postgresql/migrations/#valid-sql-migrations","text":"Using custom kotlin types in migration files means those files are no longer valid SQL. You can optionally configure a gradle task to output your migration files as valid SQL for other services to read from: sqldelight { Database { migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" // Defaults to .sql } } This creates a new task generateMainDatabaseMigrations which will output your .sqm files as valid SQL in the output directory, with the output format. Create a dependency from your compileKotlin task so that services such as flyway will have the files available on their classpath: compileKotlin . configure { dependsOn \"generateMainDatabaseMigrations\" }","title":"Valid SQL migrations"},{"location":"jvm_postgresql/query_arguments/","text":"Bind Args .sq files use the exact same syntax as PostgreSQL, including bound arguments. If a statement contains bind args, the associated method will require corresponding arguments. Type Inference SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Named Arguments Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" ) Variable Arguments Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" )) Inserts INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Arguments"},{"location":"jvm_postgresql/query_arguments/#bind-args","text":".sq files use the exact same syntax as PostgreSQL, including bound arguments. If a statement contains bind args, the associated method will require corresponding arguments.","title":"Bind Args"},{"location":"jvm_postgresql/query_arguments/#type-inference","text":"SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\"","title":"Type Inference"},{"location":"jvm_postgresql/query_arguments/#named-arguments","text":"Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Named Arguments"},{"location":"jvm_postgresql/query_arguments/#variable-arguments","text":"Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" ))","title":"Variable Arguments"},{"location":"jvm_postgresql/query_arguments/#inserts","text":"INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Inserts"},{"location":"jvm_postgresql/transactions/","text":"API If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithReturn function. val players = database . playerQueries . transactionWithReturn { database . playerQueries . selectAll (). executeAsList () } Rollback Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted = database . playerQueries . transactionWithReturn { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size } Callbacks You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \"${players.size} players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"jvm_postgresql/transactions/#api","text":"If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithReturn function. val players = database . playerQueries . transactionWithReturn { database . playerQueries . selectAll (). executeAsList () }","title":"API"},{"location":"jvm_postgresql/transactions/#rollback","text":"Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted = database . playerQueries . transactionWithReturn { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size }","title":"Rollback"},{"location":"jvm_postgresql/transactions/#callbacks","text":"You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \"${players.size} players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Callbacks"},{"location":"jvm_postgresql/types/","text":"PostgreSQL Types SQLDelight column definitions are identical to regular PostgreSQL column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. CREATE TABLE some_types ( some_smallint SMALLINT , -- Retrieved as Short some_int2 INT2 , -- Retrieved as Short some_integer INTEGER , -- Retrieved as Int some_int INT , -- Retrieved as Int some_int4 INT4 , -- Retrieved as Int some_bigint BIGINT , -- Retrieved as Long some_int8 INT8 , -- Retrieved as Long some_numeric NUMERIC , -- Retrieved as Long some_decimal DECIMAL , -- Retrieved as Long some_real REAL , -- Retrieved as Double some_float4 FLOAT4 , -- Retrieved as Double some_double_prec DOUBLE PRECISION , -- Retrieved as Double some_float8 FLOAT8 , -- Retrieved as Double some_smallserial SMALLSERIAL , -- Retrieved as Short some_serial2 SERIAL2 , -- Retrieved as Short some_serial SERIAL , -- Retrieved as Int some_serial4 SERIAL4 , -- Retrieved as Int some_bigserial BIGSERIAL , -- Retrieved as Long some_serial8 SERIAL8 , -- Retrieved as Long some_character CHARACTER , -- Retrieved as String some_char CHAR , -- Retrieved as String some_char_var CHARACTER VARYING ( 16 ), -- Retrieved as String some_varchar VARCHAR ( 16 ), -- Retrieved as String some_text TEXT , -- Retrieved as String some_date DATE , -- Retrieved as String some_time TIME , -- Retrieved as String some_timestamp TIMESTAMP , -- Retrieved as String some_json JSON -- Retrieved as String ); Custom Column Types If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) ) Enums As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) ) Custom Types in Migrations If migrations are the schema's source of truth, you can also specify the exposed kotlin type when altering a table: import kotlin . collection . List ; ALTER TABLE my_table ADD COLUMN new_column VARCHAR ( 8 ) AS List < String > ;","title":"Types"},{"location":"jvm_postgresql/types/#postgresql-types","text":"SQLDelight column definitions are identical to regular PostgreSQL column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. CREATE TABLE some_types ( some_smallint SMALLINT , -- Retrieved as Short some_int2 INT2 , -- Retrieved as Short some_integer INTEGER , -- Retrieved as Int some_int INT , -- Retrieved as Int some_int4 INT4 , -- Retrieved as Int some_bigint BIGINT , -- Retrieved as Long some_int8 INT8 , -- Retrieved as Long some_numeric NUMERIC , -- Retrieved as Long some_decimal DECIMAL , -- Retrieved as Long some_real REAL , -- Retrieved as Double some_float4 FLOAT4 , -- Retrieved as Double some_double_prec DOUBLE PRECISION , -- Retrieved as Double some_float8 FLOAT8 , -- Retrieved as Double some_smallserial SMALLSERIAL , -- Retrieved as Short some_serial2 SERIAL2 , -- Retrieved as Short some_serial SERIAL , -- Retrieved as Int some_serial4 SERIAL4 , -- Retrieved as Int some_bigserial BIGSERIAL , -- Retrieved as Long some_serial8 SERIAL8 , -- Retrieved as Long some_character CHARACTER , -- Retrieved as String some_char CHAR , -- Retrieved as String some_char_var CHARACTER VARYING ( 16 ), -- Retrieved as String some_varchar VARCHAR ( 16 ), -- Retrieved as String some_text TEXT , -- Retrieved as String some_date DATE , -- Retrieved as String some_time TIME , -- Retrieved as String some_timestamp TIMESTAMP , -- Retrieved as String some_json JSON -- Retrieved as String );","title":"PostgreSQL Types"},{"location":"jvm_postgresql/types/#custom-column-types","text":"If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) )","title":"Custom Column Types"},{"location":"jvm_postgresql/types/#enums","text":"As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Enums"},{"location":"jvm_postgresql/types/#custom-types-in-migrations","text":"If migrations are the schema's source of truth, you can also specify the exposed kotlin type when altering a table: import kotlin . collection . List ; ALTER TABLE my_table ADD COLUMN new_column VARCHAR ( 8 ) AS List < String > ;","title":"Custom Types in Migrations"},{"location":"jvm_sqlite/","text":"Getting Started on JVM with SQLite First apply the gradle plugin in your project. buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.4.1' } } apply plugin: 'com.squareup.sqldelight' sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" } } Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: dependencies { implementation \"com.squareup.sqldelight:sqlite-driver:1.4.1\" } val driver : SqlDriver = JdbcSqliteDriver ( JdbcSqliteDriver . IN_MEMORY ) Database . Schema . create ( driver ) SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Getting Started"},{"location":"jvm_sqlite/#getting-started-on-jvm-with-sqlite","text":"First apply the gradle plugin in your project. buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.4.1' } } apply plugin: 'com.squareup.sqldelight' sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" } } Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: dependencies { implementation \"com.squareup.sqldelight:sqlite-driver:1.4.1\" } val driver : SqlDriver = JdbcSqliteDriver ( JdbcSqliteDriver . IN_MEMORY ) Database . Schema . create ( driver ) SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Getting Started on JVM with SQLite"},{"location":"jvm_sqlite/coroutines/","text":"Flow To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides: dependencies { implementation \"com.squareup.sqldelight:coroutines-extensions-jvm:1.4.1\" } val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Coroutines"},{"location":"jvm_sqlite/coroutines/#flow","text":"To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides: dependencies { implementation \"com.squareup.sqldelight:coroutines-extensions-jvm:1.4.1\" } val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Flow"},{"location":"jvm_sqlite/custom_projections/","text":"Projections By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"jvm_sqlite/custom_projections/#projections","text":"By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"jvm_sqlite/gradle/","text":"Gradle For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // The dialect version you would like to target // Defaults to \"sqlite:3.18\" dialect = \"sqlite:3.24\" } } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) dialect = \"sqlite:3.24\" } } Dependencies You can specify schema dependencies on another module: sqldelight { MyDatabase { package = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: sqldelight { MyDatabase { package = \"com.example.projectb\" } }","title":"Gradle"},{"location":"jvm_sqlite/gradle/#gradle","text":"For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // The dialect version you would like to target // Defaults to \"sqlite:3.18\" dialect = \"sqlite:3.24\" } } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) dialect = \"sqlite:3.24\" } }","title":"Gradle"},{"location":"jvm_sqlite/gradle/#dependencies","text":"You can specify schema dependencies on another module: sqldelight { MyDatabase { package = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: sqldelight { MyDatabase { package = \"com.example.projectb\" } }","title":"Dependencies"},{"location":"jvm_sqlite/grouping_statements/","text":"You can group multiple SQL statements together to be executed at once: upsert { UPDATE myTable SET column1 = : column1 , column2 = : column2 WHERE id = : id ; INSERT OR IGNORE INTO myTable ( id , column1 , column2 ) VALUES (: id , : column1 , : column2 ); }","title":"Grouping Statements"},{"location":"jvm_sqlite/intellij_plugin/","text":"IntelliJ Plugin The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight MarketplaceWidget.setupMarketplaceWidget('install', 8191, \"#intellij-plugin-button\");","title":"IntelliJ Plugin"},{"location":"jvm_sqlite/intellij_plugin/#intellij-plugin","text":"The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight MarketplaceWidget.setupMarketplaceWidget('install', 8191, \"#intellij-plugin-button\");","title":"IntelliJ Plugin"},{"location":"jvm_sqlite/migrations/","text":"Migrations The .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. Versioning The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; These SQL statements are run by Database.Schema.migrate() . Migration files go in the same source set as your .sq files. Verifying Migrations You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task, which is available once you specify a schemaOutputDirectory , as described in the gradle.md . You should probably do this before you create your first migration.","title":"Migrations"},{"location":"jvm_sqlite/migrations/#migrations","text":"The .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date.","title":"Migrations"},{"location":"jvm_sqlite/migrations/#versioning","text":"The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; These SQL statements are run by Database.Schema.migrate() . Migration files go in the same source set as your .sq files.","title":"Versioning"},{"location":"jvm_sqlite/migrations/#verifying-migrations","text":"You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task, which is available once you specify a schemaOutputDirectory , as described in the gradle.md . You should probably do this before you create your first migration.","title":"Verifying Migrations"},{"location":"jvm_sqlite/query_arguments/","text":"Bind Args .sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments. Type Inference SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Named Arguments Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" ) Variable Arguments Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" )) Inserts INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Arguments"},{"location":"jvm_sqlite/query_arguments/#bind-args","text":".sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments.","title":"Bind Args"},{"location":"jvm_sqlite/query_arguments/#type-inference","text":"SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\"","title":"Type Inference"},{"location":"jvm_sqlite/query_arguments/#named-arguments","text":"Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Named Arguments"},{"location":"jvm_sqlite/query_arguments/#variable-arguments","text":"Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" ))","title":"Variable Arguments"},{"location":"jvm_sqlite/query_arguments/#inserts","text":"INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Inserts"},{"location":"jvm_sqlite/rxjava/","text":"RxJava To observe a query, depend on the RxJava extensions artifact and use the extension method it provides: dependencies { implementation \"com.squareup.sqldelight:rxjava3-extensions:1.4.1\" } val players : Observable < List < HockeyPlayer >> = playerQueries . selectAll () . asObservable () . mapToList () Note: For RxJava 2, use rxjava2-extensions as the artifact name.","title":"RxJava"},{"location":"jvm_sqlite/rxjava/#rxjava","text":"To observe a query, depend on the RxJava extensions artifact and use the extension method it provides: dependencies { implementation \"com.squareup.sqldelight:rxjava3-extensions:1.4.1\" } val players : Observable < List < HockeyPlayer >> = playerQueries . selectAll () . asObservable () . mapToList () Note: For RxJava 2, use rxjava2-extensions as the artifact name.","title":"RxJava"},{"location":"jvm_sqlite/transactions/","text":"API If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithReturn function. val players = database . playerQueries . transactionWithReturn { database . playerQueries . selectAll (). executeAsList () } Rollback Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted = database . playerQueries . transactionWithReturn { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size } Callbacks You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \"${players.size} players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"jvm_sqlite/transactions/#api","text":"If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithReturn function. val players = database . playerQueries . transactionWithReturn { database . playerQueries . selectAll (). executeAsList () }","title":"API"},{"location":"jvm_sqlite/transactions/#rollback","text":"Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted = database . playerQueries . transactionWithReturn { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size }","title":"Rollback"},{"location":"jvm_sqlite/transactions/#callbacks","text":"You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \"${players.size} players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Callbacks"},{"location":"jvm_sqlite/types/","text":"SQLite Types SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. SQLDelight natively supports Long, Double, String, ByteArray, Int, Short, Float, and Booleans. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray some_int INTEGER AS Int , -- Stored as INTEGER in db, retrieved as Int some_short INTEGER AS Short , -- Stored as INTEGER in db, retrieved as Short some_float REAL AS Float -- Stored as REAL in db, retrieved as Float ); Boolean columns are stored in the db as INTEGER , and so they can be given INTEGER column constraints. Use DEFAULT 0 to default to false, for example. CREATE TABLE hockey_player ( injured INTEGER AS Boolean DEFAULT 0 ) Custom Column Types If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) ) Enums As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Types"},{"location":"jvm_sqlite/types/#sqlite-types","text":"SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. SQLDelight natively supports Long, Double, String, ByteArray, Int, Short, Float, and Booleans. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray some_int INTEGER AS Int , -- Stored as INTEGER in db, retrieved as Int some_short INTEGER AS Short , -- Stored as INTEGER in db, retrieved as Short some_float REAL AS Float -- Stored as REAL in db, retrieved as Float ); Boolean columns are stored in the db as INTEGER , and so they can be given INTEGER column constraints. Use DEFAULT 0 to default to false, for example. CREATE TABLE hockey_player ( injured INTEGER AS Boolean DEFAULT 0 )","title":"SQLite Types"},{"location":"jvm_sqlite/types/#custom-column-types","text":"If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) )","title":"Custom Column Types"},{"location":"jvm_sqlite/types/#enums","text":"As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Enums"},{"location":"multiplatform_sqlite/","text":"Getting Started with Multiplatform First apply the gradle plugin in your project. buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.4.1' } } apply plugin: 'com.squareup.sqldelight' sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" } } Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: kotlin { // The drivers needed will change depending on what platforms you target: sourceSets . androidMain . dependencies { implementation \"com.squareup.sqldelight:android-driver:1.4.1\" } // or sourceSets.iosMain, sourceSets.windowsMain, etc. sourceSets . nativeMain . dependencies { implementation \"com.squareup.sqldelight:native-driver:1.4.1\" } sourceSets . jvmMain . dependencies { implementation \"com.squareup.sqldelight:sqlite-driver:1.4.1\" } } // in src/commonMain/kotlin expect class DriverFactory { expect fun createDriver (): SqlDriver } fun createDatabase ( driverFactory ): Database { val driver = driverFactory . createDriver () val database = Database ( driver ) // Do more work with the database (see below). } // in src/androidMain/kotlin actual class DriverFactory ( private val context : Context ) { actual fun createDriver (): SqlDriver { return AndroidSqliteDriver ( Database . Schema , context , \"test.db\" ) } } // in src/nativeMain/kotlin actual class DriverFactory { actual fun createDriver (): SqlDriver { return NativeSqliteDriver ( Database . Schema , \"test.db\" ) } } // in src/jvmMain/kotlin actual class DriverFactory { actual fun createDriver (): SqlDriver { val driver : SqlDriver = JdbcSqliteDriver ( JdbcSqliteDriver . IN_MEMORY ) Database . Schema . create ( driver ) return driver } } SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Getting Started"},{"location":"multiplatform_sqlite/#getting-started-with-multiplatform","text":"First apply the gradle plugin in your project. buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.4.1' } } apply plugin: 'com.squareup.sqldelight' sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" } } Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: kotlin { // The drivers needed will change depending on what platforms you target: sourceSets . androidMain . dependencies { implementation \"com.squareup.sqldelight:android-driver:1.4.1\" } // or sourceSets.iosMain, sourceSets.windowsMain, etc. sourceSets . nativeMain . dependencies { implementation \"com.squareup.sqldelight:native-driver:1.4.1\" } sourceSets . jvmMain . dependencies { implementation \"com.squareup.sqldelight:sqlite-driver:1.4.1\" } } // in src/commonMain/kotlin expect class DriverFactory { expect fun createDriver (): SqlDriver } fun createDatabase ( driverFactory ): Database { val driver = driverFactory . createDriver () val database = Database ( driver ) // Do more work with the database (see below). } // in src/androidMain/kotlin actual class DriverFactory ( private val context : Context ) { actual fun createDriver (): SqlDriver { return AndroidSqliteDriver ( Database . Schema , context , \"test.db\" ) } } // in src/nativeMain/kotlin actual class DriverFactory { actual fun createDriver (): SqlDriver { return NativeSqliteDriver ( Database . Schema , \"test.db\" ) } } // in src/jvmMain/kotlin actual class DriverFactory { actual fun createDriver (): SqlDriver { val driver : SqlDriver = JdbcSqliteDriver ( JdbcSqliteDriver . IN_MEMORY ) Database . Schema . create ( driver ) return driver } } SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Getting Started with Multiplatform"},{"location":"multiplatform_sqlite/coroutines/","text":"Flow To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides: kotlin { sourceSets . commonMain . dependencies { implementation \"com.squareup.sqldelight:coroutines-extensions:1.4.1\" } } val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Coroutines"},{"location":"multiplatform_sqlite/coroutines/#flow","text":"To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides: kotlin { sourceSets . commonMain . dependencies { implementation \"com.squareup.sqldelight:coroutines-extensions:1.4.1\" } } val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Flow"},{"location":"multiplatform_sqlite/custom_projections/","text":"Projections By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"multiplatform_sqlite/custom_projections/#projections","text":"By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"multiplatform_sqlite/gradle/","text":"Gradle For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // The dialect version you would like to target // Defaults to \"sqlite:3.18\" dialect = \"sqlite:3.24\" } // For native targets, whether sqlite should be automatically linked. // Defaults to true. linkSqlite = false } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) dialect = \"sqlite:3.24\" } linkSqlite = false } Dependencies You can specify schema dependencies on another module: sqldelight { MyDatabase { package = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: sqldelight { MyDatabase { package = \"com.example.projectb\" } }","title":"Gradle"},{"location":"multiplatform_sqlite/gradle/#gradle","text":"For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // The dialect version you would like to target // Defaults to \"sqlite:3.18\" dialect = \"sqlite:3.24\" } // For native targets, whether sqlite should be automatically linked. // Defaults to true. linkSqlite = false } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) dialect = \"sqlite:3.24\" } linkSqlite = false }","title":"Gradle"},{"location":"multiplatform_sqlite/gradle/#dependencies","text":"You can specify schema dependencies on another module: sqldelight { MyDatabase { package = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: sqldelight { MyDatabase { package = \"com.example.projectb\" } }","title":"Dependencies"},{"location":"multiplatform_sqlite/grouping_statements/","text":"You can group multiple SQL statements together to be executed at once: upsert { UPDATE myTable SET column1 = : column1 , column2 = : column2 WHERE id = : id ; INSERT OR IGNORE INTO myTable ( id , column1 , column2 ) VALUES (: id , : column1 , : column2 ); }","title":"Grouping Statements"},{"location":"multiplatform_sqlite/intellij_plugin/","text":"IntelliJ Plugin The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight MarketplaceWidget.setupMarketplaceWidget('install', 8191, \"#intellij-plugin-button\");","title":"IntelliJ Plugin"},{"location":"multiplatform_sqlite/intellij_plugin/#intellij-plugin","text":"The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight MarketplaceWidget.setupMarketplaceWidget('install', 8191, \"#intellij-plugin-button\");","title":"IntelliJ Plugin"},{"location":"multiplatform_sqlite/migrations/","text":"Migrations The .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. Versioning The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; These SQL statements are run by Database.Schema.migrate() . Migration files go in the same source set as your .sq files. Verifying Migrations You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task, which is available once you specify a schemaOutputDirectory , as described in the gradle.md . You should probably do this before you create your first migration.","title":"Migrations"},{"location":"multiplatform_sqlite/migrations/#migrations","text":"The .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date.","title":"Migrations"},{"location":"multiplatform_sqlite/migrations/#versioning","text":"The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; These SQL statements are run by Database.Schema.migrate() . Migration files go in the same source set as your .sq files.","title":"Versioning"},{"location":"multiplatform_sqlite/migrations/#verifying-migrations","text":"You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task, which is available once you specify a schemaOutputDirectory , as described in the gradle.md . You should probably do this before you create your first migration.","title":"Verifying Migrations"},{"location":"multiplatform_sqlite/query_arguments/","text":"Bind Args .sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments. Type Inference SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Named Arguments Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" ) Variable Arguments Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" )) Inserts INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Arguments"},{"location":"multiplatform_sqlite/query_arguments/#bind-args","text":".sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments.","title":"Bind Args"},{"location":"multiplatform_sqlite/query_arguments/#type-inference","text":"SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\"","title":"Type Inference"},{"location":"multiplatform_sqlite/query_arguments/#named-arguments","text":"Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Named Arguments"},{"location":"multiplatform_sqlite/query_arguments/#variable-arguments","text":"Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" ))","title":"Variable Arguments"},{"location":"multiplatform_sqlite/query_arguments/#inserts","text":"INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Inserts"},{"location":"multiplatform_sqlite/resources/","text":"Other Resources Guides Introduction to Multiplatform Persistence with SQLDelight Multiplatform Persistence with SQLDelight Samples https://github.com/joreilly/PeopleInSpace (Android/iOS/watchOS/macOS/Web) https://github.com/JakeWharton/SdkSearch (Android/Web) https://github.com/saket/press (Android/macOS) https://github.com/cashapp/sqldelight/tree/master/sample (Android/iOS/Web)","title":"Resources"},{"location":"multiplatform_sqlite/resources/#other-resources","text":"","title":"Other Resources"},{"location":"multiplatform_sqlite/resources/#guides","text":"Introduction to Multiplatform Persistence with SQLDelight Multiplatform Persistence with SQLDelight","title":"Guides"},{"location":"multiplatform_sqlite/resources/#samples","text":"https://github.com/joreilly/PeopleInSpace (Android/iOS/watchOS/macOS/Web) https://github.com/JakeWharton/SdkSearch (Android/Web) https://github.com/saket/press (Android/macOS) https://github.com/cashapp/sqldelight/tree/master/sample (Android/iOS/Web)","title":"Samples"},{"location":"multiplatform_sqlite/transactions/","text":"API If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithReturn function. val players = database . playerQueries . transactionWithReturn { database . playerQueries . selectAll (). executeAsList () } Rollback Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted = database . playerQueries . transactionWithReturn { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size } Callbacks You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \"${players.size} players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"multiplatform_sqlite/transactions/#api","text":"If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithReturn function. val players = database . playerQueries . transactionWithReturn { database . playerQueries . selectAll (). executeAsList () }","title":"API"},{"location":"multiplatform_sqlite/transactions/#rollback","text":"Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted = database . playerQueries . transactionWithReturn { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size }","title":"Rollback"},{"location":"multiplatform_sqlite/transactions/#callbacks","text":"You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \"${players.size} players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Callbacks"},{"location":"multiplatform_sqlite/types/","text":"SQLite Types SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. SQLDelight natively supports Long, Double, String, ByteArray, Int, Short, Float, and Booleans. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray some_int INTEGER AS Int , -- Stored as INTEGER in db, retrieved as Int some_short INTEGER AS Short , -- Stored as INTEGER in db, retrieved as Short some_float REAL AS Float -- Stored as REAL in db, retrieved as Float ); Boolean columns are stored in the db as INTEGER , and so they can be given INTEGER column constraints. Use DEFAULT 0 to default to false, for example. CREATE TABLE hockey_player ( injured INTEGER AS Boolean DEFAULT 0 ) Custom Column Types If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) ) Enums As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Types"},{"location":"multiplatform_sqlite/types/#sqlite-types","text":"SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. SQLDelight natively supports Long, Double, String, ByteArray, Int, Short, Float, and Booleans. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray some_int INTEGER AS Int , -- Stored as INTEGER in db, retrieved as Int some_short INTEGER AS Short , -- Stored as INTEGER in db, retrieved as Short some_float REAL AS Float -- Stored as REAL in db, retrieved as Float ); Boolean columns are stored in the db as INTEGER , and so they can be given INTEGER column constraints. Use DEFAULT 0 to default to false, for example. CREATE TABLE hockey_player ( injured INTEGER AS Boolean DEFAULT 0 )","title":"SQLite Types"},{"location":"multiplatform_sqlite/types/#custom-column-types","text":"If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) )","title":"Custom Column Types"},{"location":"multiplatform_sqlite/types/#enums","text":"As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Enums"},{"location":"native_sqlite/","text":"Getting started on Kotlin Native with SQLDelight First apply the gradle plugin in your project. buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.4.1' } } apply plugin: 'com.squareup.sqldelight' sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" } } Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: kotlin { // or sourceSets.iosMain, sourceSets.windowsMain, etc. sourceSets . nativeMain . dependencies { implementation \"com.squareup.sqldelight:native-driver:1.4.1\" } } val driver : SqlDriver = NativeSqliteDriver ( Database . Schema , \"test.db\" ) SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Getting Started"},{"location":"native_sqlite/#getting-started-on-kotlin-native-with-sqldelight","text":"First apply the gradle plugin in your project. buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.4.1' } } apply plugin: 'com.squareup.sqldelight' sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" } } Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: kotlin { // or sourceSets.iosMain, sourceSets.windowsMain, etc. sourceSets . nativeMain . dependencies { implementation \"com.squareup.sqldelight:native-driver:1.4.1\" } } val driver : SqlDriver = NativeSqliteDriver ( Database . Schema , \"test.db\" ) SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Getting started on Kotlin Native with SQLDelight"},{"location":"native_sqlite/coroutines/","text":"Flow To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides: kotlin { sourceSets . commonMain . dependencies { implementation \"com.squareup.sqldelight:coroutines-extensions:1.4.1\" } } val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Coroutines"},{"location":"native_sqlite/coroutines/#flow","text":"To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides: kotlin { sourceSets . commonMain . dependencies { implementation \"com.squareup.sqldelight:coroutines-extensions:1.4.1\" } } val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Flow"},{"location":"native_sqlite/custom_projections/","text":"Projections By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"native_sqlite/custom_projections/#projections","text":"By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"native_sqlite/gradle/","text":"Gradle For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // The dialect version you would like to target // Defaults to \"sqlite:3.18\" dialect = \"sqlite:3.24\" } // For native targets, whether sqlite should be automatically linked. // Defaults to true. linkSqlite = false } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) dialect = \"sqlite:3.24\" } linkSqlite = false } Dependencies You can specify schema dependencies on another module: sqldelight { MyDatabase { package = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: sqldelight { MyDatabase { package = \"com.example.projectb\" } }","title":"Gradle"},{"location":"native_sqlite/gradle/#gradle","text":"For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // The dialect version you would like to target // Defaults to \"sqlite:3.18\" dialect = \"sqlite:3.24\" } // For native targets, whether sqlite should be automatically linked. // Defaults to true. linkSqlite = false } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) dialect = \"sqlite:3.24\" } linkSqlite = false }","title":"Gradle"},{"location":"native_sqlite/gradle/#dependencies","text":"You can specify schema dependencies on another module: sqldelight { MyDatabase { package = \"com.example.projecta\" dependency project ( \":ProjectB\" ) } } This looks for MyDatabase in ProjectB and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name ( MyDatabase in this case) but generate in a different package, so here is what ProjectB 's gradle might look like: sqldelight { MyDatabase { package = \"com.example.projectb\" } }","title":"Dependencies"},{"location":"native_sqlite/grouping_statements/","text":"You can group multiple SQL statements together to be executed at once: upsert { UPDATE myTable SET column1 = : column1 , column2 = : column2 WHERE id = : id ; INSERT OR IGNORE INTO myTable ( id , column1 , column2 ) VALUES (: id , : column1 , : column2 ); }","title":"Grouping Statements"},{"location":"native_sqlite/intellij_plugin/","text":"IntelliJ Plugin The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight MarketplaceWidget.setupMarketplaceWidget('install', 8191, \"#intellij-plugin-button\");","title":"IntelliJ Plugin"},{"location":"native_sqlite/intellij_plugin/#intellij-plugin","text":"The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight MarketplaceWidget.setupMarketplaceWidget('install', 8191, \"#intellij-plugin-button\");","title":"IntelliJ Plugin"},{"location":"native_sqlite/migrations/","text":"Migrations The .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. Versioning The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; These SQL statements are run by Database.Schema.migrate() . Migration files go in the same source set as your .sq files. Verifying Migrations You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task, which is available once you specify a schemaOutputDirectory , as described in the gradle.md . You should probably do this before you create your first migration.","title":"Migrations"},{"location":"native_sqlite/migrations/#migrations","text":"The .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date.","title":"Migrations"},{"location":"native_sqlite/migrations/#versioning","text":"The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; These SQL statements are run by Database.Schema.migrate() . Migration files go in the same source set as your .sq files.","title":"Versioning"},{"location":"native_sqlite/migrations/#verifying-migrations","text":"You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task, which is available once you specify a schemaOutputDirectory , as described in the gradle.md . You should probably do this before you create your first migration.","title":"Verifying Migrations"},{"location":"native_sqlite/query_arguments/","text":"Bind Args .sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments. Type Inference SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Named Arguments Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" ) Variable Arguments Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" )) Inserts INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Arguments"},{"location":"native_sqlite/query_arguments/#bind-args","text":".sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments.","title":"Bind Args"},{"location":"native_sqlite/query_arguments/#type-inference","text":"SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\"","title":"Type Inference"},{"location":"native_sqlite/query_arguments/#named-arguments","text":"Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Named Arguments"},{"location":"native_sqlite/query_arguments/#variable-arguments","text":"Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" ))","title":"Variable Arguments"},{"location":"native_sqlite/query_arguments/#inserts","text":"INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Inserts"},{"location":"native_sqlite/transactions/","text":"API If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithReturn function. val players = database . playerQueries . transactionWithReturn { database . playerQueries . selectAll (). executeAsList () } Rollback Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted = database . playerQueries . transactionWithReturn { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size } Callbacks You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \"${players.size} players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"native_sqlite/transactions/#api","text":"If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithReturn function. val players = database . playerQueries . transactionWithReturn { database . playerQueries . selectAll (). executeAsList () }","title":"API"},{"location":"native_sqlite/transactions/#rollback","text":"Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted = database . playerQueries . transactionWithReturn { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size }","title":"Rollback"},{"location":"native_sqlite/transactions/#callbacks","text":"You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \"${players.size} players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Callbacks"},{"location":"native_sqlite/types/","text":"SQLite Types SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. SQLDelight natively supports Long, Double, String, ByteArray, Int, Short, Float, and Booleans. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray some_int INTEGER AS Int , -- Stored as INTEGER in db, retrieved as Int some_short INTEGER AS Short , -- Stored as INTEGER in db, retrieved as Short some_float REAL AS Float -- Stored as REAL in db, retrieved as Float ); Boolean columns are stored in the db as INTEGER , and so they can be given INTEGER column constraints. Use DEFAULT 0 to default to false, for example. CREATE TABLE hockey_player ( injured INTEGER AS Boolean DEFAULT 0 ) Custom Column Types If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) ) Enums As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Types"},{"location":"native_sqlite/types/#sqlite-types","text":"SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. SQLDelight natively supports Long, Double, String, ByteArray, Int, Short, Float, and Booleans. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray some_int INTEGER AS Int , -- Stored as INTEGER in db, retrieved as Int some_short INTEGER AS Short , -- Stored as INTEGER in db, retrieved as Short some_float REAL AS Float -- Stored as REAL in db, retrieved as Float ); Boolean columns are stored in the db as INTEGER , and so they can be given INTEGER column constraints. Use DEFAULT 0 to default to false, for example. CREATE TABLE hockey_player ( injured INTEGER AS Boolean DEFAULT 0 )","title":"SQLite Types"},{"location":"native_sqlite/types/#custom-column-types","text":"If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) )","title":"Custom Column Types"},{"location":"native_sqlite/types/#enums","text":"As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Enums"}]}